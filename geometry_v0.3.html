<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>EVF Emotional Geometry · v0.2</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0f172a;
      --panel: #020617;
      --ink: #e5e7eb;
      --muted: #9ca3af;
      --accent: #38bdf8;
      --border: #1f2937;
      --font: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", sans-serif;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      background: radial-gradient(circle at top, #111827, #020617 60%);
      color: var(--ink);
      font-family: var(--font);
    }
    .app {
      width: min(960px, 100vw);
      margin: 16px;
      border-radius: 16px;
      background: #020617;
      border: 1px solid #111827;
      box-shadow: 0 18px 45px rgba(0,0,0,.75), 0 0 0 1px rgba(148,163,184,.07);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .app-header {
      padding: 12px 18px;
      border-bottom: 1px solid #111827;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }
    .header-left {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    .app-title {
      font-size: 14px;
      letter-spacing: .12em;
      text-transform: uppercase;
      color: var(--muted);
    }
    .app-sub {
      font-size: 11px;
      color: var(--muted);
      opacity: .8;
    }
    .header-right {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .badge {
      border-radius: 999px;
      border: 1px solid #1e293b;
      padding: 2px 8px;
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: .12em;
      color: var(--muted);
    }
    .badge.alert {
      border-color: rgba(248,113,113,.7);
      color: #fecaca;
    }
    .info-btn {
      width: 22px;
      height: 22px;
      border-radius: 999px;
      border: 1px solid #1e293b;
      background: #020617;
      color: #cbd5f5;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 13px;
      cursor: pointer;
      padding: 0;
    }
    .app-body {
      padding: 10px 16px 4px;
      display: flex;
      flex-direction: column;
      gap: 14px;
    }

    /* Geometry section */
    .geometry-card {
      border-radius: 12px;
      border: 1px solid #111827;
      background: radial-gradient(circle at top, #020617, #020617 55%, #000);
      padding: 10px 12px 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .geometry-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      font-size: 11px;
      color: var(--muted);
      padding: 0 2px;
    }
    .geometry-title {
      text-transform: uppercase;
      letter-spacing: .08em;
      font-size: 11px;
    }
    .controls-row {
      display: flex;
      gap: 8px;
      padding: 2px 2px 0;
      flex-wrap: wrap;
    }
    .mini-btn {
      padding: 6px 10px;
      font-size: 11px;
      border-radius: 6px;
      border: 1px solid #334155;
      background: #0f172a;
      color: #e5e7eb;
      cursor: pointer;
    }
    .mini-btn.secondary { background: #1e293b; }
    #evfCanvas {
      width: 100%;
      height: 320px;
      background: radial-gradient(circle at center, #020617, #020617 60%, #000);
      display: block;
      border-radius: 10px;
      margin-top: 4px;
    }
    @media (min-width: 780px) {
      #evfCanvas {
        height: 380px;
      }
    }
    .readout {
      border-top: 1px solid #111827;
      margin-top: 8px;
      padding-top: 6px;
      font-size: 11px;
      color: var(--muted);
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .metric-row {
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
    }
    .metric { font-variant-numeric: tabular-nums; }
    .metric strong { font-weight: 500; color: var(--ink); }
    .notes-list {
      margin: 0;
      padding-left: 14px;
    }
    .notes-list li { margin: 2px 0; }

    /* Assessment section */
    .assessment-card {
      border-radius: 12px;
      border: 1px solid #111827;
      background: #020617;
      padding: 10px 12px 10px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .section-title {
      font-size: 13px;
      font-weight: 600;
      margin-bottom: 2px;
    }
    .hint {
      font-size: 11px;
      color: var(--muted);
      margin-top: 2px;
    }
    .item-group-title {
      font-size: 11px;
      color: #e5e7eb;
      text-transform: uppercase;
      letter-spacing: .08em;
      margin: 6px 0 2px;
    }
    .item-row {
      padding: 4px 0 2px;
      border-bottom: 1px solid #0b1220;
    }
    .item-text {
      font-size: 11px;
      color: var(--muted);
      margin-bottom: 2px;
    }
    .item-control-row {
      display: grid;
      grid-template-columns: auto 1fr auto;
      gap: 6px;
      align-items: center;
      font-size: 10px;
      color: var(--muted);
    }
    .item-label {
      opacity: .8;
    }
    .item-slider {
      width: 100%;
      accent-color: var(--accent);
    }
    .item-value {
      font-variant-numeric: tabular-nums;
      min-width: 20px;
      text-align: right;
      color: #e5e7eb;
    }

    .assessment-actions {
      margin-top: 6px;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    /* Advanced parameters */
    .advanced-toggle {
      font-size: 11px;
      color: var(--muted);
      cursor: pointer;
      text-decoration: underline;
      margin-top: 8px;
      align-self: flex-start;
    }
    .advanced-panel {
      margin-top: 4px;
      padding-top: 6px;
      border-top: 1px solid #111827;
      display: none;
    }
    .slider-row {
      display: grid;
      grid-template-columns: 1.3fr 3fr auto;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      color: var(--muted);
      padding: 4px 0;
    }
    .slider-row input[type="range"] {
      width: 100%;
      accent-color: var(--accent);
    }
    .slider-value {
      font-variant-numeric: tabular-nums;
      font-size: 11px;
      min-width: 24px;
      text-align: right;
      color: var(--ink);
    }

    .app-footer {
      border-top: 1px solid #111827;
      padding: 6px 14px 8px;
      font-size: 10px;
      color: var(--muted);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    /* Modal */
    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(15,23,42,0.7);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 20;
    }
    .modal {
      background: #020617;
      border-radius: 12px;
      border: 1px solid #1f2933;
      max-width: 420px;
      width: calc(100% - 40px);
      padding: 14px 16px 14px;
      box-shadow: 0 18px 45px rgba(0,0,0,0.8);
      font-size: 12px;
      color: var(--muted);
    }
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 4px;
    }
    .modal-title {
      font-size: 13px;
      font-weight: 600;
      color: var(--ink);
    }
    .modal-close {
      border: none;
      background: transparent;
      color: var(--muted);
      font-size: 16px;
      cursor: pointer;
      padding: 0 4px;
    }
    .modal-section-title {
      margin-top: 8px;
      font-size: 11px;
      color: #e5e7eb;
      text-transform: uppercase;
      letter-spacing: .08em;
    }
    .modal p {
      margin: 4px 0;
      line-height: 1.45;
    }
    .modal ul {
      margin: 4px 0 4px 18px;
      padding: 0;
    }
    .modal li {
      margin: 2px 0;
    }
  </style>
</head>
<body>
<div class="app">
  <header class="app-header">
    <div class="header-left">
      <div class="app-title">emotional vector field · geometry</div>
      <div class="app-sub">diagram first · multi-item self-assessment feeding 7-axis EVF</div>
    </div>
    <div class="header-right">
      <button id="infoBtn" class="info-btn">i</button>
      <div class="badge" id="balanceBadge">pattern: mixed</div>
    </div>
  </header>

  <div class="app-body">
    <!-- Geometry first -->
    <section class="geometry-card">
      <div class="geometry-header">
        <span class="geometry-title">emotional geometry</span>
        <span id="dominantLabel"></span>
      </div>
      <div class="controls-row">
        <button id="exportSvgBtn" class="mini-btn">download svg</button>
        <button id="resetBtn" class="mini-btn secondary">reset to neutral</button>
      </div>
      <canvas id="evfCanvas"></canvas>
      <div class="readout">
        <div class="metric-row">
          <div class="metric"><strong>spikiness:</strong> <span id="spikinessValue">—</span></div>
          <div class="metric"><strong>avg radius:</strong> <span id="avgRadiusValue">—</span></div>
        </div>
        <div>
          <strong>notes:</strong>
          <ul class="notes-list" id="notesList"></ul>
        </div>
      </div>
    </section>

    <!-- Assessment underneath -->
    <section class="assessment-card">
      <div class="section-title">multi-item self-assessment</div>
      <div class="hint">
        For each statement, rate how true it feels <strong>recently</strong>. Scores are combined into EVF parameters.
      </div>
      <div id="assessment"></div>
      <div class="assessment-actions">
        <button id="applyAssessmentBtn" class="mini-btn">apply assessment → update diagram</button>
      </div>

      <div class="advanced-toggle" id="advancedToggle">
        show advanced parameters (manual override)
      </div>
      <div class="advanced-panel" id="advancedPanel">
        <div class="section-title" style="font-size:12px;margin-bottom:0;">advanced EVF parameters</div>
        <div class="hint">Adjust these if you want to directly shape the field (0–10 per axis).</div>
        <div id="sliders"></div>
      </div>
    </section>
  </div>

  <footer class="app-footer">
    <span>© 2025 Zayn Wiwchar</span>
    <span>EVF Geometry · v0.2 experimental</span>
  </footer>
</div>

<!-- info modal -->
<div class="modal-backdrop" id="infoModalBackdrop">
  <div class="modal">
    <div class="modal-header">
      <div class="modal-title">EVF Emotional Geometry · Info</div>
      <button class="modal-close" id="infoModalClose">&times;</button>
    </div>
    <p>
      This tool visualizes an <strong>emotional vector field (EVF)</strong> as a 7-axis polygon:
      damping, coupling, noise, rhythm, gradient, attractor, and coherence.
      Your answers are mapped into these parameters to shape the geometry in real time.
    </p>

    <div class="modal-section-title">how to use</div>
    <ul>
      <li>Scroll through the statements and rate each from 0–4.</li>
      <li>Click <strong>“apply assessment”</strong> to recompute the EVF parameters and update the diagram.</li>
      <li>Use <strong>advanced parameters</strong> only if you want manual control of each axis.</li>
      <li>Watch how spikiness, average radius, and notes shift as the field changes.</li>
    </ul>

    <div class="modal-section-title">disclaimer</div>
    <p>
      This is an <strong>experimental reflection tool</strong>, not a diagnostic test. It does not
      replace therapy or medical care and should not be used for clinical decisions.
    </p>
    <p>
      If you are struggling or in crisis, please seek support from a qualified mental health
      professional or local support services.
    </p>
  </div>
</div>

<script>
  // ============================================================
  // EVF GEOMETRY · DEV NOTES
  // ------------------------------------------------------------
  // - This tool visualizes an Emotional Vector Field (EVF) as a
  //   7-axis polygon: damping, coupling, noise, rhythm, gradient,
  //   attractor, coherence.
  //
  // - Parameters live in `state[param]` on a 0–10 scale.
  //   Geometry = normalized radii of these 7 values.
  //
  // - Self-assessment is multi-item per parameter:
  //     * each item rated 0–4 (Likert)
  //     * items are intentionally parallel for that parameter
  //     * no psychometric factor analysis yet
  //
  // - IMPORTANT: all items are equally weighted on purpose.
  //   There is no empirical basis (yet) for differential weighting.
  //   This keeps the mapping transparent and conceptually honest.
  //
  //   Pipeline:
  //     raw (0–4) -> normalize to 0–1 (with optional reversal)
  //     -> mean across items for that param -> scale to 0–10
  //
  // - If future data suggests different item discrimination, you
  //   can add a `weight` field to ASSESSMENT_ITEMS and change the
  //   aggregation in `applyAssessmentBtn` without touching any
  //   geometry logic.
  // ============================================================

  // ---------- config ----------
  const PARAM_ORDER = [
    'damping','coupling','noise','rhythm','gradient','attractor','coherence'
  ];
  const PARAM_LABELS = {
    damping:'damping',
    coupling:'coupling',
    noise:'noise',
    rhythm:'rhythm',
    gradient:'gradient',
    attractor:'attractor',
    coherence:'coherence'
  };

  // ------------------------------------------------------------
  // ASSESSMENT ITEMS · DEV NOTES
  // ------------------------------------------------------------
  // - Each item belongs to exactly one EVF parameter (param).
  // - `reverse: true` means higher agreement should REDUCE the
  //   parameter rather than increase it.
  //   Example:
  //     noise item "It is easy to find a quiet channel" is reverse.
  //
  // - Equal-weight design:
  //     * For now, every item contributes equally.
  //     * This is conceptually aligned with EVF: we're building a
  //       reflective geometry, not a diagnostic scale.
  //
  // - If you later want weights:
  //     * add `weight: 1.0` to each item
  //     * adjust the aggregation in applyAssessmentBtn to use
  //       weighted means.
  // ------------------------------------------------------------
  const ASSESSMENT_ITEMS = [
    // damping
    { id:'d1', param:'damping', reverse:false,
      text:'When I get emotionally activated, I can usually settle or calm down within a reasonable time.' },
    { id:'d2', param:'damping', reverse:true,
      text:'Emotions tend to linger in my body for a long time before easing.' },

    // coupling
    { id:'c1', param:'coupling', reverse:false,
      text:'Other people’s moods strongly affect my own mood.' },
    { id:'c2', param:'coupling', reverse:true,
      text:'I feel mostly insulated from other people’s emotional states.' },

    // noise
    { id:'n1', param:'noise', reverse:false,
      text:'My mind feels cluttered or noisy lately.' },
    { id:'n2', param:'noise', reverse:true,
      text:'It is easy for me to find a quiet, clear channel in my thoughts.' },

    // rhythm
    { id:'r1', param:'rhythm', reverse:false,
      text:'My days follow a fairly steady rhythm (sleep, meals, activity, rest).' },
    { id:'r2', param:'rhythm', reverse:true,
      text:'My routines feel all over the place or unpredictable.' },

    // gradient
    { id:'g1', param:'gradient', reverse:false,
      text:'I feel a clear sense of direction or pull toward something meaningful.' },
    { id:'g2', param:'gradient', reverse:true,
      text:'It is hard to care enough about anything to move toward it.' },

    // attractor
    { id:'a1', param:'attractor', reverse:false,
      text:'One theme, worry, or goal takes up a lot of my mental space.' },
    { id:'a2', param:'attractor', reverse:true,
      text:'My attention feels scattered rather than anchored to anything in particular.' },

    // coherence
    { id:'h1', param:'coherence', reverse:false,
      text:'My life and emotions make sense to me as a mostly coherent story.' },
    { id:'h2', param:'coherence', reverse:true,
      text:'Different parts of my life feel fragmented or contradictory.' }
  ];

  const MAX_SCALE = 10;
  const BASE_RADIUS = 120;

  const state = {
    damping:4, coupling:6, noise:5, rhythm:3,
    gradient:5, attractor:7, coherence:4
  };

  // ---------- DOM refs ----------
  const canvas       = document.getElementById('evfCanvas');
  const ctx          = canvas.getContext('2d');
  const spikinessEl  = document.getElementById('spikinessValue');
  const avgRadiusEl  = document.getElementById('avgRadiusValue');
  const notesListEl  = document.getElementById('notesList');
  const badgeEl      = document.getElementById('balanceBadge');
  const domLabelEl   = document.getElementById('dominantLabel');
  const exportSvgBtn = document.getElementById('exportSvgBtn');
  const resetBtn     = document.getElementById('resetBtn');

  const assessmentContainer = document.getElementById('assessment');
  const applyAssessmentBtn  = document.getElementById('applyAssessmentBtn');
  const advancedToggle      = document.getElementById('advancedToggle');
  const advancedPanel       = document.getElementById('advancedPanel');
  const slidersContainer    = document.getElementById('sliders');

  const infoBtn           = document.getElementById('infoBtn');
  const infoModalBackdrop = document.getElementById('infoModalBackdrop');
  const infoModalClose    = document.getElementById('infoModalClose');

  const itemInputs = {};  // ASSESSMENT_ITEMS id -> input
  const inputs     = {};  // PARAM_ORDER name -> slider input
  let lastResult   = null;
  let advancedVisible = false;

  // ---------- helpers ----------
  function clamp(v,min,max){ return Math.min(max,Math.max(min,v)); }
  function mean(a){ return a.length ? a.reduce((x,y)=>x+y,0)/a.length : 0; }
  function variance(a,m){ if(!a.length) return 0; const mm=m??mean(a); return mean(a.map(v=>(v-mm)**2)); }

  // ---------- EVF analysis ----------
  function analyzeEVFState(s, {order=PARAM_ORDER,maxScale=MAX_SCALE,baseRadius=BASE_RADIUS}={}) {
    const n = order.length;
    const vertices = [];
    for (let i=0;i<n;i++){
      const name = order[i];
      const raw  = clamp(s[name]??0,0,maxScale);
      const norm = raw/maxScale;
      const angle = (i/n)*Math.PI*2;
      const r = norm*baseRadius;
      const x = r*Math.cos(angle);
      const y = r*Math.sin(angle);
      vertices.push({name,raw,normalized:norm,angleRad:angle,r,x,y});
    }
    const sx = vertices.reduce((sum,v)=>sum+v.x,0);
    const sy = vertices.reduce((sum,v)=>sum+v.y,0);
    const centroid = { x: sx/vertices.length, y: sy/vertices.length };
    const radii = vertices.map(v=>v.r);
    const avgR = mean(radii);
    const varR = variance(radii,avgR);
    const spikiness = Math.sqrt(varR)/(baseRadius||1);
    const notes = interpretPattern(s,{maxScale});
    const dominantSpikes = getDominantSpikes(vertices);
    return { vertices, centroid, avgRadius:avgR, varianceRadius:varR, spikiness, dominantSpikes, notes };
  }

  function getDominantSpikes(vertices){
    if(!vertices.length) return [];
    const radii = vertices.map(v=>v.r);
    const m  = mean(radii);
    const sd = Math.sqrt(variance(radii,m))||1;
    const thresh = m + 0.7*sd;
    return vertices.filter(v=>v.r>thresh).map(v=>v.name);
  }

  function interpretPattern(s,{maxScale}){
    const norm = k => (s[k]??0)/(maxScale||10);
    const d=norm('damping'), c=norm('coupling'), n=norm('noise'),
          r=norm('rhythm'), g=norm('gradient'),
          a=norm('attractor'), h=norm('coherence');
    const notes=[];
    if(c>0.7 && d<0.5) notes.push('strong pull from others / environment, low self-buffering');
    if(a>0.7 && g>0.6 && d<0.4) notes.push('driven toward something with little braking power');
    if(n>0.6 && h<0.4) notes.push('fragmented field: high noise with low coherence');
    if(h>0.6 && r>0.4 && r<0.8) notes.push('organized pattern with workable rhythms');
    if(g<0.3 && r<0.3) notes.push('low drive and weak rhythms – risk of stagnation');
    if(!notes.length) notes.push('mixed pattern without a single dominant imbalance');
    return notes;
  }

  // ---------- UI build: assessment ----------
  function createAssessment() {
    // group items by parameter so we can show small headings
    const groupOrder = PARAM_ORDER;
    const grouped = {};
    ASSESSMENT_ITEMS.forEach(item => {
      if (!grouped[item.param]) grouped[item.param] = [];
      grouped[item.param].push(item);
    });

    groupOrder.forEach(param => {
      if (!grouped[param]) return;
      const groupTitle = document.createElement('div');
      groupTitle.className = 'item-group-title';
      groupTitle.textContent = param;
      assessmentContainer.appendChild(groupTitle);

      grouped[param].forEach(item => {
        const row = document.createElement('div');
        row.className = 'item-row';

        const text = document.createElement('div');
        text.className = 'item-text';
        text.textContent = item.text;

        const ctrl = document.createElement('div');
        ctrl.className = 'item-control-row';

        const labelLow = document.createElement('span');
        labelLow.className = 'item-label';
        labelLow.textContent = '0';

        const slider = document.createElement('input');
        slider.type = 'range';
        slider.min = '0';
        slider.max = '4';
        slider.step = '1';
        slider.value = '2'; // neutral
        slider.className = 'item-slider';

        const valueSpan = document.createElement('span');
        valueSpan.className = 'item-value';
        valueSpan.textContent = slider.value;

        slider.addEventListener('input', () => {
          valueSpan.textContent = slider.value;
        });

        itemInputs[item.id] = slider;

        ctrl.appendChild(labelLow);
        ctrl.appendChild(slider);
        ctrl.appendChild(valueSpan);

        row.appendChild(text);
        row.appendChild(ctrl);
        assessmentContainer.appendChild(row);
      });
    });
  }

  // ---------- UI build: advanced sliders ----------
  function createSliders() {
    PARAM_ORDER.forEach(name => {
      const row = document.createElement('div');
      row.className = 'slider-row';

      const label = document.createElement('label');
      label.textContent = PARAM_LABELS[name];

      const input = document.createElement('input');
      input.type = 'range';
      input.min = '0';
      input.max = String(MAX_SCALE);
      input.step = '1';
      input.value = String(state[name] ?? 0);
      inputs[name] = input;

      const valueSpan = document.createElement('span');
      valueSpan.className = 'slider-value';
      valueSpan.textContent = input.value;

      input.addEventListener('input', () => {
        state[name] = Number(input.value);
        valueSpan.textContent = input.value;
        update();
      });

      row.appendChild(label);
      row.appendChild(input);
      row.appendChild(valueSpan);
      slidersContainer.appendChild(row);
    });
  }

  // ---------- canvas ----------
  function resizeCanvas(){
    const rect = canvas.getBoundingClientRect();
    canvas.width  = rect.width * window.devicePixelRatio;
    canvas.height = rect.height * window.devicePixelRatio;
    ctx.setTransform(window.devicePixelRatio,0,0,window.devicePixelRatio,0,0);
  }

  window.addEventListener('resize', () => {
    resizeCanvas();
    update();
  });

  function drawGeometry(result){
    const {vertices,centroid,spikiness} = result;
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    const cx = w/2, cy = h/2;
    ctx.clearRect(0,0,w,h);
    ctx.save();
    ctx.translate(cx,cy);

    const rings=4;
    const maxR = Math.min(w,h)*0.36;
    ctx.strokeStyle='rgba(148,163,184,0.15)';
    ctx.lineWidth=1;
    for(let i=1;i<=rings;i++){
      const r=(i/rings)*maxR;
      ctx.beginPath();
      ctx.arc(0,0,r,0,Math.PI*2);
      ctx.stroke();
    }

    ctx.font='10px system-ui';
    ctx.fillStyle='rgba(148,163,184,0.85)';
    ctx.textAlign='center';
    ctx.textBaseline='middle';
    vertices.forEach(v=>{
      const axisR=maxR+12;
      const ax=axisR*Math.cos(v.angleRad);
      const ay=axisR*Math.sin(v.angleRad);
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.lineTo(ax,ay);
      ctx.strokeStyle='rgba(51,65,85,0.7)';
      ctx.stroke();
      const lx=(axisR+14)*Math.cos(v.angleRad);
      const ly=(axisR+14)*Math.sin(v.angleRad);
      ctx.fillText(v.name,lx,ly);
    });

    const scale=maxR/BASE_RADIUS;
    ctx.beginPath();
    vertices.forEach((v,i)=>{
      const x=v.x*scale, y=v.y*scale;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    });
    ctx.closePath();
    const intensity=Math.min(1,spikiness*2.2);
    const baseAlpha=0.18+intensity*0.15;
    ctx.fillStyle=`rgba(56,189,248,${baseAlpha})`;
    ctx.strokeStyle='rgba(56,189,248,0.8)';
    ctx.lineWidth=2;
    ctx.fill();
    ctx.stroke();

    ctx.beginPath();
    ctx.arc(centroid.x*scale,centroid.y*scale,3.5,0,Math.PI*2);
    ctx.fillStyle='#e5e7eb';
    ctx.fill();
    ctx.restore();
  }

  // ---------- SVG export ----------
  function buildSVG(result,{width=600,height=600}={}){
    const cx=width/2, cy=height/2;
    const maxR=Math.min(width,height)*0.36;
    const scale=maxR/BASE_RADIUS;
    const {vertices,centroid} = result;
    let rings='';
    const ringCount=4;
    for(let i=1;i<=ringCount;i++){
      const r=(i/ringCount)*maxR;
      rings+=`<circle cx="${cx}" cy="${cy}" r="${r.toFixed(2)}" fill="none" stroke="#1f2937" stroke-width="1"/>
`;
    }
    let axes='';
    vertices.forEach(v=>{
      const axisR=maxR+12;
      const ax=cx+axisR*Math.cos(v.angleRad);
      const ay=cy+axisR*Math.sin(v.angleRad);
      const lx=cx+(axisR+14)*Math.cos(v.angleRad);
      const ly=cy+(axisR+14)*Math.sin(v.angleRad);
      axes+=`<line x1="${cx}" y1="${cy}" x2="${ax.toFixed(2)}" y2="${ay.toFixed(2)}" stroke="#1f2937" stroke-width="1"/>
`;
      axes+=`<text x="${lx.toFixed(2)}" y="${ly.toFixed(2)}" fill="#9ca3af" font-size="11" text-anchor="middle" dominant-baseline="middle">${v.name}</text>
`;
    });
    const points = vertices.map(v=>{
      const px=cx+v.x*scale, py=cy+v.y*scale;
      return `${px.toFixed(2)},${py.toFixed(2)}`;
    }).join(' ');
    const centroidX=cx+centroid.x*scale;
    const centroidY=cy+centroid.y*scale;

    return `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">
  <rect x="0" y="0" width="${width}" height="${height}" fill="#020617"/>
  <g>
    ${rings}
    ${axes}
    <polygon points="${points}" fill="rgba(56,189,248,0.24)" stroke="#38bdf8" stroke-width="2"/>
    <circle cx="${centroidX.toFixed(2)}" cy="${centroidY.toFixed(2)}" r="4" fill="#e5e7eb"/>
  </g>
</svg>`;
  }

  function downloadSVG(result){
    const svg=buildSVG(result,{width:600,height:600});
    const blob=new Blob([svg],{type:'image/svg+xml;charset=utf-8'});
    const url=URL.createObjectURL(blob);
    const a=document.createElement('a');
    a.href=url; a.download='evf-geometry.svg';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  // ---------- update ----------
  function update(){
  // still use the v0.2 analyzer for metrics (temporary)
  const result = analyzeEVFState(state,{maxScale:MAX_SCALE,baseRadius:BASE_RADIUS});
  lastResult = result;

  // NEW: use v0.3 topology engine for visual geometry
  drawGeometry(ctx, state);

  // --- metrics & UI updates ---
  spikinessEl.textContent = result.spikiness.toFixed(2);
  avgRadiusEl.textContent = result.avgRadius.toFixed(1);

  const s = result.spikiness;
  if (s < 0.12) {
    badgeEl.textContent = 'pattern: smooth / balanced';
    badgeEl.classList.remove('alert');
  } else if (s < 0.22) {
    badgeEl.textContent = 'pattern: moderately uneven';
    badgeEl.classList.remove('alert');
  } else {
    badgeEl.textContent = 'pattern: jagged / polarized';
    badgeEl.classList.add('alert');
  }

  domLabelEl.textContent = result.dominantSpikes.length
    ? 'dominant: ' + result.dominantSpikes.join(', ')
    : '';

  notesListEl.innerHTML='';
  result.notes.forEach(t=>{
    const li=document.createElement('li');
    li.textContent=t;
    notesListEl.appendChild(li);
  });
}

  // ---------- interactions ----------
  resetBtn.addEventListener('click',()=>{
    // neutral-ish state
    PARAM_ORDER.forEach(name=>{
      state[name]=5;
      if(inputs[name]){
        inputs[name].value='5';
        inputs[name].nextSibling.textContent='5';
      }
    });
    // center assessment sliders at 2 (neutral)
    ASSESSMENT_ITEMS.forEach(item=>{
      const inp = itemInputs[item.id];
      if (inp) inp.value = '2';
    });
    update();
  });

  exportSvgBtn.addEventListener('click',()=>{
    if(!lastResult){
      lastResult=analyzeEVFState(state,{maxScale:MAX_SCALE,baseRadius:BASE_RADIUS});
    }
    downloadSVG(lastResult);
  });

  // ------------------------------------------------------------
  // APPLY ASSESSMENT · DEV NOTES
  // ------------------------------------------------------------
  // Mapping pipeline:
  //   1. Each slider is 0–4.
  //   2. If reverse == true, we flip: norm = (4 - raw)/4.
  //   3. Otherwise, norm = raw/4. Now everything is 0–1 where
  //      higher = "more of the parameter" as conceptually defined.
  //   4. For each parameter, we average its item norms (equal
  //      weight -> simple mean).
  //   5. We scale 0–1 -> 0–10 and round to an integer.
  //
  // This keeps:
  //   - a transparent relationship between items and geometry
  //   - easy swap-out of items without math surgery
  //   - room for future weighting if justified by data
  // ------------------------------------------------------------
  applyAssessmentBtn.addEventListener('click',()=>{
    // compute param scores from multi-item responses
    const sums = {};
    const counts = {};
    PARAM_ORDER.forEach(p => { sums[p]=0; counts[p]=0; });

    ASSESSMENT_ITEMS.forEach(item=>{
      const inp = itemInputs[item.id];
      if (!inp) return;
      const raw = Number(inp.value)||0; // 0..4
      const norm = item.reverse ? (4-raw)/4 : raw/4; // 0..1
      sums[item.param] += norm;
      counts[item.param] += 1;
    });

    PARAM_ORDER.forEach(param=>{
      if (counts[param] > 0) {
        const avgNorm = sums[param] / counts[param]; // 0..1
        const scaled  = Math.round(avgNorm * MAX_SCALE); // 0..10
        state[param] = scaled;
        if (inputs[param]) {
          inputs[param].value = String(scaled);
          inputs[param].nextSibling.textContent = String(scaled);
        }
      }
    });

    update();
  });

  advancedToggle.addEventListener('click',()=>{
    advancedVisible = !advancedVisible;
    advancedPanel.style.display = advancedVisible ? 'block' : 'none';
    advancedToggle.textContent = advancedVisible
      ? 'hide advanced parameters (manual override)'
      : 'show advanced parameters (manual override)';
  });

  // info modal
  infoBtn.addEventListener('click',()=>{
    infoModalBackdrop.style.display='flex';
  });
  infoModalClose.addEventListener('click',()=>{
    infoModalBackdrop.style.display='none';
  });
  infoModalBackdrop.addEventListener('click',(e)=>{
    if(e.target === infoModalBackdrop){
      infoModalBackdrop.style.display='none';
    }
  });
// ===============================
// EVF v0.3 GEOMETRY PATCH
// topology-aware field diagram
// ===============================

// canonical axis layout (matching our topology & icons)
// angles measured from canvas center, 0 at +x, CCW
const EVF_AXES = [
  { key: 'coupling',  label: 'c',         baseAngle: -Math.PI / 2 },                 // top
  { key: 'noise',     label: 'ξ',         baseAngle: -Math.PI / 2 + 2 * Math.PI / 7 }, // upper-right
  { key: 'coherence', label: 'C',         baseAngle: -Math.PI / 2 + 4 * Math.PI / 7 }, // lower-right
  { key: 'attractor', label: 'A',         baseAngle: -Math.PI / 2 + 6 * Math.PI / 7 }, // bottom-right
  { key: 'gradient',  label: '∇φ',        baseAngle: -Math.PI / 2 + 8 * Math.PI / 7 }, // bottom-left
  { key: 'rhythm',    label: 'R',         baseAngle: -Math.PI / 2 + 10 * Math.PI / 7 }, // lower-left
  { key: 'damping',   label: 'γ',         baseAngle: -Math.PI / 2 + 12 * Math.PI / 7 }  // upper-left
];

// simple clamp / lerp helpers
function clamp01(x) { return Math.max(0, Math.min(1, x)); }
function lerp(a, b, t) { return a + (b - a) * t; }

// magnitude helper (0–1) for each param
function normParam(val) {
  const v = (val == null ? 0 : val);
  return clamp01(v / 100);
}

// pair strength (used for γ–R, ∇φ–A)
function pairStrength(a, b) {
  const na = normParam(a);
  const nb = normParam(b);
  // we care about both being “on” and similar
  const mean = 0.5 * (na + nb);
  const diff = Math.abs(na - nb);
  return clamp01(mean * (1 - diff)); // strong when both high and close
}

// tension strength (ξ–C hinge)
function tensionStrength(noiseVal, cohVal) {
  const n = normParam(noiseVal);
  const c = normParam(cohVal);
  const diff = Math.abs(n - c);
  const mean = 0.5 * (n + c);
  // strong tension when both moderately active and far apart
  return clamp01(diff * (0.3 + 0.7 * mean));
}

// compute topology-aware geometry from params
function analyzeEVFStateV03(params, canvas) {
  const w = canvas.width;
  const h = canvas.height;
  const cx = w / 2;
  const cy = h / 2;

  // base radius range (min so it never collapses to center)
  const R_MIN = Math.min(w, h) * 0.12;
  const R_MAX = Math.min(w, h) * 0.42;

  // normalized values
  const n = {
    damping:   normParam(params.damping),
    coupling:  normParam(params.coupling),
    noise:     normParam(params.noise),
    rhythm:    normParam(params.rhythm),
    gradient:  normParam(params.gradient),
    attractor: normParam(params.attractor),
    coherence: normParam(params.coherence)
  };

  // pair metrics
  const sReg   = pairStrength(params.damping, params.rhythm);      // γ–R
  const sDir   = pairStrength(params.gradient, params.attractor);  // ∇φ–A
  const sHinge = tensionStrength(params.noise, params.coherence);  // ξ–C

  // base radius per axis (before topology tweaks)
  const baseRadius = {};
  EVF_AXES.forEach(ax => {
    baseRadius[ax.key] = lerp(R_MIN, R_MAX, n[ax.key]);
  });

  // ---------- ANGLE DEFORMATION (cluster compression) ----------

  const angles = {};
  EVF_AXES.forEach(ax => {
    angles[ax.key] = ax.baseAngle;
  });

  // helper to find axis index by key
  function idx(key) {
    return EVF_AXES.findIndex(ax => ax.key === key);
  }

  const sep = 2 * Math.PI / EVF_AXES.length;
  const ANGLE_CLUSTER_FACTOR = 0.25; // how much of base separation can be compressed

  // γ–R pair (regulation cluster on left)
  {
    const k1 = 'damping';
    const k2 = 'rhythm';
    const a1 = EVF_AXES[idx(k1)].baseAngle;
    const a2 = EVF_AXES[idx(k2)].baseAngle;
    const mid = 0.5 * (a1 + a2);
    const maxDelta = ANGLE_CLUSTER_FACTOR * sep * sReg;

    angles[k1] = mid - maxDelta;
    angles[k2] = mid + maxDelta;
  }

  // ∇φ–A pair (directional cluster on bottom)
  {
    const k1 = 'gradient';
    const k2 = 'attractor';
    const a1 = EVF_AXES[idx(k1)].baseAngle;
    const a2 = EVF_AXES[idx(k2)].baseAngle;
    const mid = 0.5 * (a1 + a2);
    const maxDelta = ANGLE_CLUSTER_FACTOR * sep * sDir;

    angles[k1] = mid - maxDelta;
    angles[k2] = mid + maxDelta;
  }

  // ---------- RADIUS DEFORMATION ----------

  // ξ–C hinge: exaggerate radial contrast
  const kNoise = 'noise';
  const kCoh   = 'coherence';
  {
    const rN0 = baseRadius[kNoise];
    const rC0 = baseRadius[kCoh];
    const mean = 0.5 * (rN0 + rC0);
    const diff = rN0 - rC0;
    const K_HINGE = 0.4; // strength of hinge exaggeration

    const factor = 1 + K_HINGE * sHinge;

    baseRadius[kNoise] = mean + diff * factor;
    baseRadius[kCoh]   = mean - diff * factor;
  }

  // global coupling: compression / fragmentation around mean
  const cNorm = n.coupling;
  const radii = {};
  const allR = EVF_AXES.map(ax => baseRadius[ax.key]);
  const rMean = allR.reduce((a, b) => a + b, 0) / allR.length;

  // α_c controls pull toward mean (higher coupling → tighter cluster)
  const ALPHA_MIN = 0.0;
  const ALPHA_MAX = 0.7;
  const alphaC = lerp(ALPHA_MIN, ALPHA_MAX, cNorm);

  EVF_AXES.forEach(ax => {
    const r0 = baseRadius[ax.key];
    const r1 = lerp(r0, rMean, alphaC);
    radii[ax.key] = r1;
  });

  // directional tilt: strong ∇φ–A pulls centroid downwards
  const dirScore = clamp01(sDir * ((params.gradient + params.attractor) / 200));
  const tiltOffset = (Math.min(w, h) * 0.06) * dirScore; // pixels

  // ---------- FINAL POINTS & METRICS ----------

  const points = EVF_AXES.map(ax => {
    const ang = angles[ax.key];
    const r   = radii[ax.key];

    const x = cx + r * Math.cos(ang);
    const y = (cy + tiltOffset) + r * Math.sin(ang); // apply tilt downward

    return { key: ax.key, label: ax.label, x, y, r, angle: ang };
  });

  // centroid of polygon
  let centroidX = 0, centroidY = 0;
  points.forEach(p => { centroidX += p.x; centroidY += p.y; });
  centroidX /= points.length;
  centroidY /= points.length;

  // simple spikiness / variance
  const rs = points.map(p => p.r);
  const rAvg = rs.reduce((a, b) => a + b, 0) / rs.length;
  const rVar = rs.reduce((acc, rv) => acc + Math.pow(rv - rAvg, 2), 0) / rs.length;
  const spikiness = Math.sqrt(rVar);

  return {
    points,
    centroid: { x: centroidX, y: centroidY },
    rAvg,
    rVar,
    spikiness,
    pairs: { sReg, sDir, sHinge },
    cNorm,
    n
  };
}

// ===============================
// DRAW FUNCTION (replaces old drawGeometry)
// ===============================
function drawGeometry(ctx, params) {
  const canvas = ctx.canvas;
  const w = canvas.width;
  const h = canvas.height;
  ctx.clearRect(0, 0, w, h);

  const geom = analyzeEVFStateV03(params, canvas);
  const { points, centroid, rAvg, spikiness, cNorm } = geom;
  const cx = w / 2;
  const cy = h / 2;

  // background ring (ghost field)
  ctx.save();
  ctx.translate(0, 0);
  ctx.strokeStyle = 'rgba(0,0,0,0.18)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.arc(cx, cy, rAvg, 0, Math.PI * 2);
  ctx.stroke();
  ctx.restore();

  // polygon fill (field shape)
  ctx.save();
  ctx.beginPath();
  points.forEach((p, i) => {
    if (i === 0) ctx.moveTo(p.x, p.y);
    else ctx.lineTo(p.x, p.y);
  });
  ctx.closePath();

  // fill slightly more solid if coupling is high (compressed field)
  const fillAlpha = lerp(0.08, 0.18, cNorm);
  ctx.fillStyle = `rgba(0,0,0,${fillAlpha.toFixed(3)})`;
  ctx.fill();

  ctx.lineWidth = 1.2;
  ctx.strokeStyle = 'rgba(0,0,0,0.7)';
  ctx.stroke();
  ctx.restore();

  // radial spokes + nodes
  ctx.save();
  ctx.lineWidth = 0.7;
  ctx.strokeStyle = 'rgba(0,0,0,0.35)';
  ctx.font = '10px system-ui, -apple-system, sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  points.forEach(p => {
    // spoke
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(p.x, p.y);
    ctx.stroke();

    // node
    ctx.beginPath();
    ctx.fillStyle = '#fff';
    ctx.strokeStyle = 'rgba(0,0,0,0.9)';
    ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();

    // label (parameter symbol)
    const labelR = 10;
    const lx = p.x + labelR * Math.cos(p.angle);
    const ly = p.y + labelR * Math.sin(p.angle);
    ctx.fillStyle = 'rgba(0,0,0,0.8)';
    ctx.fillText(p.label, lx, ly);
  });
  ctx.restore();

  // centroid dot
  ctx.save();
  ctx.beginPath();
  ctx.fillStyle = 'rgba(0,0,0,0.7)';
  ctx.arc(centroid.x, centroid.y, 2, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();

  // optional: tiny metrics in corner (spikiness, coupling)
  ctx.save();
  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  ctx.font = '10px system-ui, -apple-system, sans-serif';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  const sp = spikiness.toFixed(1);
  const cP = Math.round(geom.cNorm * 100);
  ctx.fillText(`spike: ${sp}`, 8, 8);
  ctx.fillText(`coupling: ${cP}`, 8, 20);
  ctx.restore();
}
  // ---------- init ----------
  createAssessment();
  createSliders();
  resizeCanvas();
  update();
</script>
</body>
</html>

<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>Ripple Reveal · Ambient</title>
<style>
  html,body { margin:0; height:100%; background:#000; }
  .stage { position:fixed; inset:0; overflow:hidden; }
  .bg, .bg > * { position:absolute; inset:0; width:100%; height:100%; object-fit:cover; display:block; }
  .bg { pointer-events:none; }       /* let input reach the canvas */
  canvas { position:absolute; inset:0; width:100%; height:100%; display:block; }

  /* Minimal scale button */
  #scaleBtn{
    position:fixed; bottom:1rem; right:1rem;
    background:rgba(20,20,22,.5); color:#cfcfd4;
    border:1px solid rgba(255,255,255,.12);
    border-radius:6px; padding:.35rem .6rem;
    font:500 13px/1 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    cursor:pointer; backdrop-filter: blur(6px);
    transition: background .25s ease, color .25s ease, opacity .25s ease;
    opacity:.85;
  }
  #scaleBtn:hover{ background: rgba(26,26,30,.62); color:#fff; opacity:1; }
</style>
</head>
<body>
<div class="stage">
  <div class="bg">
    <!-- Project-site path; for user/org site remove "zaynwebsite" -->
    <video id="bgVideo" muted playsinline loop preload="auto" poster="">
      <source src="/zaynwebsite/assets/videos/Landingloop.mp4" type="video/mp4">
    </video>
  </div>
  <canvas id="c"></canvas>
</div>

<button id="scaleBtn">scale: pentatonicMinor</button>

<script>
(() => {
  // --------------------- Canvas / Visuals ---------------------
  const video = document.getElementById('bgVideo');
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  // Aesthetic knobs
  const COVER_ALPHA = 0.85;          // veil strength over video
  const RING_COUNT = 4;
  const RING_SPACING = 30;
  const BASE_WIDTH = 2;
  const LIFE_MS = 1600;
  const SPEED = 220;
  const EDGE = 'hsla(210,8%,80%,ALPHA)'; // muted cool-grey edge

  // Two-finger "depth" shadow (very subtle)
  const SHADOW_ALPHA = 0.16;
  const SHADOW_BLUR = 4;
  const SHADOW_OFFSET_Y = 1;
  const SHADOW_WIDTH_SCALE = 1.12;

  // DPR & resize
  let dpr = window.devicePixelRatio || 1;
  function resize(){
    const w = innerWidth, h = innerHeight;
    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  addEventListener('resize', resize, { passive:true });
  resize();

  // Try to start video; iOS will need first tap
  function tryPlay(){ const p = video.play?.(); if (p?.catch) p.catch(()=>{}); }
  video.addEventListener('canplay', tryPlay);
  addEventListener('pointerdown', tryPlay, { once:true, passive:true });
  tryPlay();

  // Ripple state
  const ripples = [];
  function addRipple(x, y, opts={}){
    ripples.push({
      x, y, t0: performance.now(),
      opacity: opts.opacity ?? (0.25 + Math.random()*0.5),
      widthJitter: opts.widthJitter ?? (0.8 + Math.random()*0.8),
      life: opts.life ?? LIFE_MS,
      speed: opts.speed ?? SPEED,
      sizeMul: opts.sizeMul ?? 1,
      depth: !!opts.depth
    });
  }

  function frame(now){
    // veil
    ctx.clearRect(0,0,canvas.width/dpr,canvas.height/dpr);
    ctx.fillStyle = `rgba(0,0,0,${COVER_ALPHA})`;
    ctx.fillRect(0,0,canvas.width/dpr,canvas.height/dpr);

    for (let i = ripples.length - 1; i >= 0; i--){
      const r = ripples[i];
      const age = now - r.t0;
      if (age > r.life) { ripples.splice(i,1); continue; }

      const base = (age/1000) * r.speed;
      const life = 1 - age / r.life;
      const baseAlpha = (r.opacity * life);
      const width = BASE_WIDTH * r.widthJitter * (1 + 0.25 * Math.sin(age * 0.005));

      // Cut through veil
      ctx.globalCompositeOperation = 'destination-out';
      ctx.strokeStyle = 'rgba(0,0,0,1)';
      ctx.lineWidth = width;
      for (let k=0;k<RING_COUNT;k++){
        const rad = (base + k*RING_SPACING) * r.sizeMul; if (rad<=0) continue;
        ctx.beginPath(); ctx.arc(r.x, r.y, rad, 0, Math.PI*2); ctx.stroke();
      }

      // Edge (same hue for all)
      ctx.globalCompositeOperation = 'source-over';
      const edge = EDGE.replace('ALPHA', (baseAlpha*0.4).toFixed(3));
      ctx.strokeStyle = edge;
      ctx.lineWidth = width;
      for (let k=0;k<RING_COUNT;k++){
        const rad = (base + k*RING_SPACING) * r.sizeMul; if (rad<=0) continue;
        ctx.beginPath(); ctx.arc(r.x, r.y, rad, 0, Math.PI*2); ctx.stroke();
      }

      // Subtle depth shadow for multitouch
      if (r.depth && baseAlpha > 0.02){
        ctx.save();
        ctx.shadowBlur = SHADOW_BLUR;
        ctx.shadowColor = `rgba(0,0,0,${(SHADOW_ALPHA*life).toFixed(3)})`;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = SHADOW_OFFSET_Y;
        ctx.strokeStyle = 'rgba(0,0,0,0)';
        ctx.lineWidth = width * SHADOW_WIDTH_SCALE;
        for (let k=0;k<RING_COUNT;k++){
          const rad = (base + k*RING_SPACING) * r.sizeMul; if (rad<=0) continue;
          ctx.beginPath(); ctx.arc(r.x, r.y, rad, 0, Math.PI*2); ctx.stroke();
        }
        ctx.restore();
      }
    }

    ctx.globalCompositeOperation = 'source-over';
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  // --------------------- Audio (Web Audio, mobile-safe) ---------------------
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  const audioCtx = new AudioCtx();
  let audioBooted = false;

  async function bootAudioOnce() {
    if (audioBooted) return;
    try {
      if (audioCtx.state !== 'running') await audioCtx.resume();
      // 1-sample silent buffer trick to fully unlock
      const silent = audioCtx.createBuffer(1, 1, audioCtx.sampleRate);
      const src = audioCtx.createBufferSource();
      src.buffer = silent; src.connect(audioCtx.destination); src.start(0);
      audioBooted = true;
      console.log('[ripple] audio unlocked');
    } catch(e){ console.warn('[ripple] audio unlock failed:', e); }
  }
  addEventListener('pointerdown', bootAudioOnce, { once:true, passive:true });
  addEventListener('touchstart',  bootAudioOnce, { once:true, passive:true });

  // Scales & notes
  const SCALES = {
    major:               [0,2,4,5,7,9,11],
    naturalMinor:        [0,2,3,5,7,8,10],
    dorian:              [0,2,3,5,7,9,10],
    pentatonicMajor:     [0,2,4,7,9],
    pentatonicMinor:     [0,3,5,7,10],
    lydian:              [0,2,4,6,7,9,11],
    mixolydian:          [0,2,4,5,7,9,10],
  };
  const scaleBtn = document.getElementById('scaleBtn');
  const scaleNames = Object.keys(SCALES);
  let currentScaleIndex = scaleNames.indexOf('pentatonicMinor');

  let ROOT_MIDI = 62; // D4
  let OCTAVES_UP = 1, OCTAVES_DOWN = 1;
  let SCALE = SCALES[scaleNames[currentScaleIndex]];

  function buildScalePool(rootMidi, steps, up, down){
    const pool = [];
    for (let o = -down; o <= up; o++){
      const base = rootMidi + 12*o;
      for (const s of steps) pool.push(base + s);
    }
    return pool.sort((a,b)=>a-b);
  }
  let NOTE_POOL = buildScalePool(ROOT_MIDI, SCALE, OCTAVES_UP, OCTAVES_DOWN);

  function setScaleByName(name){
    SCALE = SCALES[name];
    NOTE_POOL = buildScalePool(ROOT_MIDI, SCALE, OCTAVES_UP, OCTAVES_DOWN);
    if (scaleBtn) scaleBtn.textContent = `scale: ${name}`;
  }
  scaleBtn.addEventListener('click', () => {
    currentScaleIndex = (currentScaleIndex + 1) % scaleNames.length;
    const next = scaleNames[currentScaleIndex];
    setScaleByName(next);
  });

  function midiToFreq(m) { return 440 * Math.pow(2, (m - 69) / 12); }

  // Clustered chord picker (tight, ambient)
  const CLUSTER_RADIUS_STEPS = 2; // tightness
  function pickClusterNotes(count){
    const N = NOTE_POOL.length;
    if (!N) return [];
    const center = Math.floor(N * 0.55); // slightly bright center
    const notes = [];
    const offsetsByCount = { 1:[0], 2:[0,1], 3:[-1,0,1] };
    const baseOffsets = offsetsByCount[Math.min(3, count)];
    for (const off of baseOffsets){
      const jitter = Math.floor((Math.random()*(CLUSTER_RADIUS_STEPS*2+1)) - CLUSTER_RADIUS_STEPS);
      const idx = Math.max(0, Math.min(N-1, center + off + jitter));
      notes.push(NOTE_POOL[idx]);
    }
    return notes;
  }

  // Play a ripple tone; supports explicit freq + tiny detune cents; gentle pan by x
  function playRippleSound(x, isDepth = false, freqOverride = null, detuneCents = 0) {
    if (!audioBooted) return;

    // Default: pick from pool (upper half for singles; lower for depth), unless override provided
    const half = Math.floor(NOTE_POOL.length / 2);
    const idx = isDepth
      ? Math.floor(Math.random() * Math.max(1, half))
      : Math.floor(half + Math.random() * Math.max(1, NOTE_POOL.length - half));
    const freq = freqOverride ?? midiToFreq(
      NOTE_POOL[Math.min(NOTE_POOL.length - 1, Math.max(0, idx))]
    );

    const now = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    const panner = audioCtx.createStereoPanner ? audioCtx.createStereoPanner() : null;

    osc.type = 'triangle';
    osc.frequency.setValueAtTime(freq, now);
    if (detuneCents) osc.detune.setValueAtTime(detuneCents, now);
    // tiny glide
    osc.frequency.linearRampToValueAtTime(freq * (isDepth ? 0.997 : 1.003), now + 0.15);

    const startGain = isDepth ? 0.05 : 0.04;
    const dur = isDepth ? 1.2 : 0.9;
    gain.gain.setValueAtTime(startGain, now);
    gain.gain.exponentialRampToValueAtTime(0.0001, now + dur);

    if (panner) {
      const pan = (x / window.innerWidth) * 2 - 1;
      panner.pan.setValueAtTime(pan * 0.6, now);
      osc.connect(gain); gain.connect(panner); panner.connect(audioCtx.destination);
    } else {
      osc.connect(gain); gain.connect(audioCtx.destination);
    }

    osc.start(now);
    osc.stop(now + dur + 0.1);
  }

  // --------------------- Interaction ---------------------
  // Mouse / single pointer
  canvas.addEventListener('pointerdown', e => {
    if (e.touches) return;
    const x = e.clientX, y = e.clientY;
    addRipple(x, y);
    playRippleSound(x, false);
  }, { passive:true });

  // Touch: 1–3 finger clustered chords; ripple at each finger
  canvas.addEventListener('touchstart', e => {
    const touches = Array.from(e.touches);
    const count = Math.min(touches.length, 3);
    if (count === 0) return;

    const chord = pickClusterNotes(count);
    const detunesByCount = { 1:[0], 2:[-4, +4], 3:[-5, 0, +5] };

    for (let i = 0; i < count; i++) {
      const t = touches[i];
      const x = t.clientX, y = t.clientY;

      addRipple(x, y, {
        opacity: 0.42 + Math.random()*0.08,
        widthJitter: 0.95 + Math.random()*0.4,
        life: LIFE_MS * (1.1 + Math.random()*0.25),
        speed: SPEED * (0.85 + Math.random()*0.15),
        sizeMul: 1 + Math.random()*0.2,
        depth: count > 1
      });

      const midi = chord[i];
      const freq = midiToFreq(midi);
      playRippleSound(x, count>1, freq, detunesByCount[count][i] || 0);
    }
  }, { passive:true });

})();
</script>
</body>
</html>

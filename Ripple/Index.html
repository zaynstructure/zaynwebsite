<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>Ripple Reveal – Subtle Depth (Two-Finger)</title>
<style>
html,body { margin:0; height:100%; background:#000; }
.stage { position:fixed; inset:0; overflow:hidden; }
.bg, .bg > * { position:absolute; inset:0; width:100%; height:100%; object-fit:cover; display:block; }
.bg { pointer-events:none; }
canvas { position:absolute; inset:0; width:100%; height:100%; display:block; }
</style>
</head>
<body>
<div class="stage">
<div class="bg">
<video id="bgVideo" muted playsinline loop preload="auto">
<source src="/assets/videos/Landingloop.mp4" type="video/mp4">
</video>
</div>
<canvas id="c"></canvas>
</div>

<script>
(() => {
const video=document.getElementById('bgVideo');
const canvas=document.getElementById('c');
const ctx=canvas.getContext('2d');

// ---- Tweakables (kept minimal) ----
const COVER_ALPHA=1.25;
const RING_COUNT=4, RING_SPACING=30, BASE_WIDTH=2;
const LIFE_MS=1600, SPEED=220;
const EDGE='hsla(210,8%,80%,ALPHA)'; // muted edge hue
// Depth (only for two-finger ripples)
const SHADOW_ALPHA=0.18; // overall shadow strength
const SHADOW_BLUR=4; // softness (px)
const SHADOW_OFFSET_Y=1; // slight downward offset (px)
const SHADOW_WIDTH_SCALE=1.15; // make shadow a touch thicker
// -----------------------------------

let dpr=window.devicePixelRatio||1;
function resize(){
const w=innerWidth,h=innerHeight;
canvas.width=w*dpr; canvas.height=h*dpr;
canvas.style.width=w+'px'; canvas.style.height=h+'px';
ctx.setTransform(dpr,0,0,dpr,0,0);
}
addEventListener('resize',resize,{passive:true}); resize();

// kick video
function tryPlay(){ const p=video.play?.(); if(p?.catch) p.catch(()=>{}); }
video.addEventListener('canplay',tryPlay);
addEventListener('pointerdown',tryPlay,{once:true,passive:true});
tryPlay();

const ripples=[];
function addRipple(x,y,opts={}){
ripples.push({
x,y,t0:performance.now(),
opacity:opts.opacity??(0.25+Math.random()*0.5),
widthJitter:opts.widthJitter??(0.8+Math.random()*0.8),
life:opts.life??LIFE_MS,
speed:opts.speed??SPEED,
sizeMul:opts.sizeMul??1,
depth:opts.depth??false // two-finger marks depth = true
});
}

// --- Audio context setup ---
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

// Utility: make a soft ping
function playRippleSound(isDepth = false) {
if (audioCtx.state === 'suspended') audioCtx.resume(); // resume on iOS
const osc = audioCtx.createOscillator();
const gain = audioCtx.createGain();

// Subtle variation: random between two octaves
const baseFreq = isDepth ? 180 : 280;
const freq = baseFreq + Math.random() * 40;
osc.frequency.value = freq;

// Tone: triangle for softness
osc.type = 'triangle';

// Envelope: gentle fade-out
gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
gain.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.9);

osc.connect(gain);
gain.connect(audioCtx.destination);
osc.start();
osc.stop(audioCtx.currentTime + 1);
}

// pointer (mouse)
canvas.addEventListener('pointerdown', e=>{
if(e.touches) return;
addRipple(e.clientX,e.clientY);
playRippleSound(false);
},{passive:true});

// touch – one or two fingers
canvas.addEventListener('touchstart',e=>{
const t=e.touches;
if(t.length===1){
addRipple(t[0].clientX,t[0].clientY);
playRippleSound(false);
} else if(t.length===2){
const x=(t[0].clientX+t[1].clientX)/2;
const y=(t[0].clientY+t[1].clientY)/2;
addRipple(x,y,{
opacity:0.55, widthJitter:1.4,
life:LIFE_MS*1.3, speed:SPEED*0.8,
sizeMul:1.25, depth:true
});
playRippleSound(true);
}
},{passive:true});


function frame(now){
ctx.clearRect(0,0,canvas.width/dpr,canvas.height/dpr);
ctx.fillStyle=`rgba(0,0,0,${COVER_ALPHA})`;
ctx.fillRect(0,0,canvas.width/dpr,canvas.height/dpr);

for(let i=ripples.length-1;i>=0;i--){
const r=ripples[i];
const age=now-r.t0;
if(age>r.life){ ripples.splice(i,1); continue; }

const base=(age/1000)*r.speed;
const life=1-age/r.life;
const baseAlpha=(r.opacity*life);
const width=BASE_WIDTH*r.widthJitter*(1+0.25*Math.sin(age*0.005));

// 1) Reveal cut
ctx.globalCompositeOperation='destination-out';
ctx.strokeStyle='rgba(0,0,0,1)';
ctx.lineWidth=width;
for(let k=0;k<RING_COUNT;k++){
const rad=(base+k*RING_SPACING)*r.sizeMul; if(rad<=0) continue;
ctx.beginPath(); ctx.arc(r.x,r.y,rad,0,Math.PI*2); ctx.stroke();
}

// 2) Edge (same hue)
ctx.globalCompositeOperation='source-over';
const edge=EDGE.replace('ALPHA',(baseAlpha*0.4).toFixed(3));
ctx.strokeStyle=edge;
ctx.lineWidth=width;
for(let k=0;k<RING_COUNT;k++){
const rad=(base+k*RING_SPACING)*r.sizeMul; if(rad<=0) continue;
ctx.beginPath(); ctx.arc(r.x,r.y,rad,0,Math.PI*2); ctx.stroke();
}

// 3) Subtle depth shadow (two-finger only)
if (r.depth && baseAlpha>0.02){
ctx.save();
ctx.shadowBlur = SHADOW_BLUR;
ctx.shadowColor = `rgba(0,0,0,${(SHADOW_ALPHA*life).toFixed(3)})`;
ctx.shadowOffsetX = 0;
ctx.shadowOffsetY = SHADOW_OFFSET_Y;
ctx.strokeStyle = 'rgba(0,0,0,0)'; // stroke invisible; only shadow shows
ctx.lineWidth = width * SHADOW_WIDTH_SCALE;
for(let k=0;k<RING_COUNT;k++){
const rad=(base+k*RING_SPACING)*r.sizeMul; if(rad<=0) continue;
ctx.beginPath(); ctx.arc(r.x,r.y,rad,0,Math.PI*2); ctx.stroke();
}
ctx.restore();
}
}
ctx.globalCompositeOperation='source-over';
requestAnimationFrame(frame);
}
requestAnimationFrame(frame);
})();
</script>
</body>
</html>



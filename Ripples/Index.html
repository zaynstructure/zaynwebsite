<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>Ripples · Ambient</title>
<style>
  html,body { margin:0; height:100%; background:#000; }
  .stage { position:fixed; inset:0; overflow:hidden; }
  .bg, .bg > * { position:absolute; inset:0; width:100%; height:100%; object-fit:cover; display:block; }
  .bg { pointer-events:none; }
  canvas { position:absolute; inset:0; width:100%; height:100%; display:block; }

  #ui { position:fixed; inset:auto 0 0 auto; padding:12px; display:flex; gap:8px; align-items:center; }
  .btn {
    background:rgba(20,20,22,.5); color:#cfcfd4;
    border:1px solid rgba(255,255,255,.12);
    border-radius:6px; padding:.35rem .6rem;
    font:500 13px/1 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    cursor:pointer; backdrop-filter:blur(6px);
    transition:background .2s ease, color .2s ease, opacity .2s ease;
    opacity:.9;
  }
  .btn:hover{ background:rgba(26,26,30,.62); color:#fff; opacity:1; }
  #badge {
    font:600 11px/1 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    color:#bbb; padding:.35rem .5rem; border-radius:6px;
    background:rgba(0,0,0,.35); border:1px solid rgba(255,255,255,.12);
  }
  #badge.on { color:#7fffb2; border-color:rgba(127,255,178,.35); }

  #credit {
    position:fixed;
    top:0.6rem;
    right:0.75rem;
    font:400 11px/1.2 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    color:rgba(255,255,255,0.35);
    letter-spacing:0.4px;
    pointer-events:none;
    user-select:none;
    z-index:3;
  }

  /* Instruction overlay */
  #instruction {
    position: fixed;
    left: 50%;
    bottom: 50%;
    transform: translate(-50%, 50%);
    font: 500 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    color: rgba(255,255,255,0.82);
    letter-spacing: 0.4px;
    text-align: center;
    opacity: 0;
    pointer-events: none;
    transition: opacity 1.5s ease;
    z-index: 3;
    padding: .4rem .6rem;
    background: rgba(0,0,0,.25);
    border: 1px solid rgba(255,255,255,.12);
    border-radius: 8px;
    backdrop-filter: blur(6px);
  }
</style>
</head>
<body>
<div class="stage">
  <div class="bg">
    <video id="bgVideo" muted playsinline loop preload="auto">
      <source src="/assets/videos/Landingloop.mp4" type="video/mp4">
    </video>
  </div>
  <canvas id="c"></canvas>
</div>

<div id="ui">
  <button id="modeSetBtn" class="btn">set: D-minorish</button>
  <button id="scaleBtn"   class="btn">scale: dorian</button>
  <button id="soundBtn"   class="btn">sound: enable</button>
  <div id="badge">AUDIO: OFF</div>
</div>

<div id="instruction">tap to begin · turn your phone off silent mode for sound</div>
<div id="credit">v1 · zayn wiwchar</div>

<script>
(() => {
  // ---------------- Visuals ----------------
  const video  = document.getElementById('bgVideo');
  const canvas = document.getElementById('c');
  const ctx    = canvas.getContext('2d');

  // Ripple appearance knobs
  const COVER_ALPHA   = 1.25;  // veil over the video (kept at your requested 1.25)
  const RING_COUNT    = 4;
  const RING_SPACING  = 30;
  const BASE_WIDTH    = 2;
  const LIFE_MS       = 1000;
  const SPEED         = 220;

  // Brightness & fade controls
  const RING_GAIN       = 1.8;   // outline brightness multiplier
  const EDGE_LIGHTNESS  = 93;    // % lightness of edge
  const EDGE_SAT        = 6;     // % saturation of edge
  const REVEAL_STRENGTH = 1.15;  // stronger mask => more background reveal
  const FADE_EXP        = 1.6;   // lower => longer/brighter linger
  const RING_FALLOFF    = 0.9;   // <1 dims outer rings

  function edgeColor(alpha){ return `hsla(210, ${EDGE_SAT}%, ${EDGE_LIGHTNESS}%, ${alpha})`; }

  const SHADOW_ALPHA=0.16, SHADOW_BLUR=4, SHADOW_OFFSET_Y=1, SHADOW_WIDTH_SCALE=1.12;

  let dpr = window.devicePixelRatio || 1;
  function resize(){
    const w=innerWidth, h=innerHeight;
    canvas.width=Math.floor(w*dpr);
    canvas.height=Math.floor(h*dpr);
    canvas.style.width=w+'px'; canvas.style.height=h+'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  addEventListener('resize', resize, {passive:true}); resize();

  function tryPlayBg(){ const p = video.play?.(); if (p?.catch) p.catch(()=>{}); }
  video.addEventListener('canplay', tryPlayBg);
  addEventListener('pointerdown', tryPlayBg, {once:true, passive:true});
  tryPlayBg();

  const ripples = [];
  function addRipple(x, y, opts = {}) {
    ripples.push({
      x, y, t0: performance.now(),
      opacity:     opts.opacity     ?? (0.35 + Math.random()*0.25), // brightness variation
      widthJitter: opts.widthJitter ?? (0.85 + Math.random()*0.45), // organic line width
      sizeMul:     opts.sizeMul     ?? (0.95 + Math.random()*0.15), // radius wobble
      life:        opts.life        ?? LIFE_MS * (1.15 + Math.random()*0.25),
      speed:       opts.speed       ?? SPEED   * (0.90 + Math.random()*0.15),
      depth:       !!opts.depth
    });
  }

  function frame(now){
    ctx.clearRect(0,0,canvas.width/dpr,canvas.height/dpr);
    const veilAlpha = Math.min(1, Math.max(0, COVER_ALPHA));
    ctx.fillStyle=`rgba(0,0,0,${veilAlpha})`;
    ctx.fillRect(0,0,canvas.width/dpr,canvas.height/dpr);

    for (let i=ripples.length-1;i>=0;i--){
      const r=ripples[i], age=now-r.t0;
      if (age>r.life){ ripples.splice(i,1); continue; }

      const base = (age/1000)*r.speed;
      const life = 1 - age / r.life;
      const fade = Math.pow(life, FADE_EXP);
      const baseAlpha = r.opacity * fade;
      const width = BASE_WIDTH * r.widthJitter * (1 + 0.75*Math.sin(age*0.005));

      for (let k=0; k<RING_COUNT; k++){
        const rad = (base + k*RING_SPACING) * r.sizeMul;
        if (rad <= 0) continue;
        const ringGain = Math.pow(RING_FALLOFF, k);

        // reveal (mask)
        ctx.globalCompositeOperation = 'destination-out';
        ctx.strokeStyle = `rgba(0,0,0,${Math.min(1, fade * REVEAL_STRENGTH * ringGain).toFixed(3)})`;
        ctx.lineWidth = width;
        ctx.beginPath(); ctx.arc(r.x, r.y, rad, 0, Math.PI*2); ctx.stroke();

        // edge stroke
        ctx.globalCompositeOperation = 'source-over';
        const edgeAlpha = baseAlpha * 0.4 * RING_GAIN * ringGain;
        ctx.strokeStyle = edgeColor(edgeAlpha.toFixed(3));
        ctx.lineWidth = width;
        ctx.beginPath(); ctx.arc(r.x, r.y, rad, 0, Math.PI*2); ctx.stroke();
      }

      // depth shadow (optional)
      if (r.depth && baseAlpha>0.02){
        ctx.save();
        ctx.shadowBlur=SHADOW_BLUR;
        ctx.shadowColor=`rgba(0,0,0,${(SHADOW_ALPHA*life).toFixed(3)})`;
        ctx.shadowOffsetX=0; ctx.shadowOffsetY=SHADOW_OFFSET_Y;
        ctx.strokeStyle='rgba(0,0,0,0)'; ctx.lineWidth=width*SHADOW_WIDTH_SCALE;
        for(let k=0;k<RING_COUNT;k++){
          const rad=(base+k*RING_SPACING)*r.sizeMul; if(rad<=0) continue;
          ctx.beginPath(); ctx.arc(r.x,r.y,rad,0,Math.PI*2); ctx.stroke();
        }
        ctx.restore();
      }
    }
    ctx.globalCompositeOperation='source-over';
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  // ---------------- Audio ----------------
  const modeSetBtn = document.getElementById('modeSetBtn');
  const scaleBtn   = document.getElementById('scaleBtn');
  const soundBtn   = document.getElementById('soundBtn');
  const badge      = document.getElementById('badge');
  const instrEl    = document.getElementById('instruction');

  let audioCtx = null;
  let audioBooted = false;

  function ensureAudioContext(){
    if (!audioCtx) {
      const AC = window.AudioContext || window.webkitAudioContext;
      audioCtx = new AC();
    }
    return audioCtx;
  }

  // Ambient pad (buffer-based with tail trim)
  let padBuf=null, padSrc=null, padGain=null, padLoopEnd=null;

  async function loadPadBuffer(url){
    const res = await fetch(url, {cache:'force-cache'});
    const arr = await res.arrayBuffer();
    return await audioCtx.decodeAudioData(arr);
  }

  function analyzeTail(buffer, searchSec=3.0, threshold=0.0008, safetyMs=20){
    const sr = buffer.sampleRate, len = buffer.length;
    const start = Math.max(0, len - Math.floor(searchSec*sr));
    const ch0 = buffer.getChannelData(0);
    const ch1 = buffer.numberOfChannels > 1 ? buffer.getChannelData(1) : null;
    let lastLoud = start;
    for (let i=len-1;i>=start;i--){
      const a0 = Math.abs(ch0[i]);
      const a1 = ch1 ? Math.abs(ch1[i]) : 0;
      const a  = a0 > a1 ? a0 : a1;
      if (a > threshold){ lastLoud = i; break; }
    }
    const safety = Math.floor((safetyMs/1000)*sr);
    const endIdx = Math.min(len, lastLoud + safety);
    return endIdx / sr;
  }

  function startPadBuffer(loopStart=0.0, loopEndSec=null, targetGain=0.22, fadeSec=4){
    if (!padBuf) return;
    if (padSrc) { try{ padSrc.stop(); }catch(_){} padSrc.disconnect(); padSrc = null; }

    padSrc = audioCtx.createBufferSource();
    padSrc.buffer = padBuf;
    padSrc.loop = true;
    padSrc.loopStart = loopStart;
    padSrc.loopEnd   = loopEndSec ?? padBuf.duration;

    if (!padGain){
      padGain = audioCtx.createGain();
      padGain.gain.setValueAtTime(0.0, audioCtx.currentTime);
      padGain.connect(audioCtx.destination);
    }

    padSrc.connect(padGain);
    padSrc.start();

    const now = audioCtx.currentTime;
    padGain.gain.cancelScheduledValues(now);
    padGain.gain.setValueAtTime(padGain.gain.value, now);
    padGain.gain.linearRampToValueAtTime(targetGain, now + fadeSec);
  }

  function fadePadTo(target, seconds=3){
    if (!padGain) return;
    const now = audioCtx.currentTime;
    padGain.gain.cancelScheduledValues(now);
    padGain.gain.setValueAtTime(padGain.gain.value, now);
    padGain.gain.linearRampToValueAtTime(target, now + seconds);
  }

  async function bootAudioOnce(){
    ensureAudioContext();
    if (audioBooted) return;
    try {
      if (audioCtx.state !== 'running') await audioCtx.resume();

      // 1-sample unlock
      const silent = audioCtx.createBuffer(1, 1, audioCtx.sampleRate);
      const src = audioCtx.createBufferSource();
      src.buffer = silent; src.connect(audioCtx.destination); src.start(0);

      // Load pad & trim tail
      if (!padBuf){
        padBuf = await loadPadBuffer('/assets/Ripplesloop.m4a');
        padLoopEnd = analyzeTail(padBuf, 3.0, 0.0008, 20);
      }
      startPadBuffer(0.0, padLoopEnd, 0.22, 4);

      audioBooted = true;
      badge.textContent = 'AUDIO: ON'; badge.classList.add('on');
      soundBtn.textContent = 'sound: enabled';
      testBeep();
      // Hide instruction on first successful boot (if visible)
      if (instrEl) instrEl.style.opacity = 0;
    } catch (e){
      console.warn('[ripple] audio unlock failed:', e);
    }
  }

  function testBeep(){
    const now = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type='sine';
    osc.frequency.value = 660;
    gain.gain.setValueAtTime(0.08, now);
    gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.25);
    osc.connect(gain); gain.connect(audioCtx.destination);
    osc.start(now); osc.stop(now + 0.3);
  }

  // ---------------- Scales / Modes ----------------
  const SCALES = {
    major:[0,2,4,5,7,9,11],
    naturalMinor:[0,2,3,5,7,8,10],   // Aeolian
    dorian:[0,2,3,5,7,9,10],
    pentatonicMajor:[0,2,4,7,9],
    pentatonicMinor:[0,3,5,7,10],
    lydian:[0,2,4,6,7,9,11],
    mixolydian:[0,2,4,5,7,9,10],
  };
  const scaleNames = Object.keys(SCALES);

  // Root D4, default to D dorian
  let ROOT_MIDI = 62;
  let OCTAVES_UP = 1, OCTAVES_DOWN = 1;

  // Curated sets that gel with your D–A–E pad
  const MODE_SETS = {
    'D-minorish': ['dorian','pentatonicMinor'],
    'D-majorish': ['mixolydian','pentatonicMajor'],
    'D-moodier' : ['naturalMinor','pentatonicMinor'],
  };
  const modeSetNames = Object.keys(MODE_SETS);
  let currentModeSetIdx = 0;
  let activeModes = MODE_SETS[modeSetNames[currentModeSetIdx]];

  let currentScaleIndex = scaleNames.indexOf('dorian');
  let SCALE = SCALES['dorian'];

  function buildScalePool(rootMidi, steps, up, down){
    const pool=[];
    for(let o=-down;o<=up;o++){
      const base=rootMidi+12*o;
      for(const s of steps) pool.push(base+s);
    }
    return pool.sort((a,b)=>a-b);
  }
  let NOTE_POOL = buildScalePool(ROOT_MIDI, SCALE, OCTAVES_UP, OCTAVES_DOWN);

  function setScaleByName(name){
    if (!activeModes.includes(name)) name = activeModes[0];
    SCALE = SCALES[name];
    NOTE_POOL = buildScalePool(ROOT_MIDI, SCALE, OCTAVES_UP, OCTAVES_DOWN);
    currentScaleIndex = scaleNames.indexOf(name);
    scaleBtn.textContent = `scale: ${name}`;
  }

  // Cycle within the active mode set
  scaleBtn.addEventListener('click', () => {
    const currentName = scaleNames[currentScaleIndex];
    const i = activeModes.indexOf(currentName);
    const next = activeModes[(i + 1) % activeModes.length];
    setScaleByName(next);
  });

  // Switch mode set
  modeSetBtn.addEventListener('click', () => {
    currentModeSetIdx = (currentModeSetIdx + 1) % modeSetNames.length;
    activeModes = MODE_SETS[modeSetNames[currentModeSetIdx]];
    modeSetBtn.textContent = `set: ${modeSetNames[currentModeSetIdx]}`;
    setScaleByName(activeModes[0]);
  });
  modeSetBtn.textContent = `set: ${modeSetNames[currentModeSetIdx]}`;
  setScaleByName('dorian');

  // D/E/A friendly weighting
  function degreeFromRoot(m){ return ((m - ROOT_MIDI) % 12 + 12) % 12; }
  function degreeWeight(deg){
    const setName = modeSetNames[currentModeSetIdx];
    if (setName === 'D-moodier') {
      const table = { 0:2.0, 2:1.6, 7:1.5, 5:1.3, 3:1.2, 8:0.7, 10:0.7 };
      return (table[deg] ?? 1.0);
    }
    const base = { 0:1.8, 7:1.5, 2:1.3 };
    return (base[deg] ?? 1.0);
  }
  function weightedPick(pool){
    if (!pool.length) return null;
    let total = 0;
    const acc = pool.map(m => (total += degreeWeight(degreeFromRoot(m))));
    const r = Math.random() * total;
    const idx = acc.findIndex(a => a >= r);
    return pool[Math.max(0, idx)];
  }

  // Register pickers (vertical thirds)
  function pickBassNote(){
    const N = NOTE_POOL.length; if (!N) return ROOT_MIDI - 12;
    const lowSliceEnd = Math.max(1, Math.floor(N * 0.45));
    const lowPool = NOTE_POOL.slice(0, lowSliceEnd);
    const lowPick = weightedPick(lowPool) ?? NOTE_POOL[0];
    const drop = (Math.random() < 0.7 ? 12 : 24); // usually -12, sometimes -24
    const minBassMidi = ROOT_MIDI - 24;           // lifted for phone audibility
    const maxBassMidi = ROOT_MIDI - 12;
    return Math.max(minBassMidi, Math.min(maxBassMidi, lowPick - drop));
  }
  function pickMidNote(){
    const N = NOTE_POOL.length; if (!N) return ROOT_MIDI;
    const midStart = Math.floor(N * 0.35), midEnd = Math.floor(N * 0.8);
    const midPool = NOTE_POOL.slice(midStart, Math.max(midStart+1, midEnd));
    return weightedPick(midPool) ?? NOTE_POOL[Math.floor(N*0.55)];
  }
  function pickHighNote(){
    const N = NOTE_POOL.length; if (!N) return ROOT_MIDI + 7;
    const hiStart = Math.floor(N * 0.65);
    const hiPool = NOTE_POOL.slice(hiStart).filter(m => m <= ROOT_MIDI + 24);
    return weightedPick(hiPool) ?? NOTE_POOL[N-1];
  }

  // Simple synth voice
  function midiToFreq(m){ return 440 * Math.pow(2, (m-69)/12); }

  function playRippleSound(x, isDepth=false, freqOverride=null, detuneCents=0, voice='normal'){
    if (!audioBooted) return;

    const half = Math.floor(NOTE_POOL.length/2);
    const idx  = isDepth
      ? Math.floor(Math.random()*Math.max(1, half))
      : Math.floor(half + Math.random()*Math.max(1, NOTE_POOL.length-half));
    const freq = freqOverride ?? midiToFreq(NOTE_POOL[Math.min(NOTE_POOL.length-1, Math.max(0, idx))]);

    const now = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    const panNode = audioCtx.createStereoPanner ? audioCtx.createStereoPanner() : null;

    osc.type='triangle'; // triangle for all voices (incl. bass)
    osc.frequency.setValueAtTime(freq, now);
    if (detuneCents) osc.detune.setValueAtTime(detuneCents, now);
    osc.frequency.linearRampToValueAtTime(freq * (isDepth ? 0.997 : 1.003), now + 0.15);

    const startGain = (voice==='bass') ? 0.05 : (isDepth ? 0.05 : 0.04);
    const dur       = (voice==='bass') ? 1.5  : (isDepth ? 1.2 : 0.9);
    gain.gain.setValueAtTime(startGain, now);
    gain.gain.exponentialRampToValueAtTime(0.0001, now + dur);

    if (panNode){
      const pan = (x / window.innerWidth) * 2 - 1;
      const panScale = (voice==='bass') ? 0.25 : 0.6; // bass more centered
      panNode.pan.setValueAtTime(pan * panScale, now);
      osc.connect(gain); gain.connect(panNode); panNode.connect(audioCtx.destination);
    } else {
      osc.connect(gain); gain.connect(audioCtx.destination);
    }

    osc.start(now); osc.stop(now + dur + 0.1);
  }

  // ---------------- Input / Unlock ----------------
  const detunesByCount = { 1:[0], 2:[-4,+4], 3:[-5,0,+5] };

  soundBtn.addEventListener('click', bootAudioOnce, { passive:true });
  addEventListener('pointerdown', bootAudioOnce, { once:true, passive:true });
  addEventListener('touchstart',  bootAudioOnce, { once:true, passive:true });

  // Mouse: single voice (mid register picker still uses NOTE_POOL if freqOverride not passed)
  canvas.addEventListener('pointerdown', e=>{
    if (e.touches) return;
    const x=e.clientX, y=e.clientY;
    addRipple(x,y);
    playRippleSound(x, false);
  }, {passive:true});

  // Touch: vertical thirds → bass / mid / high
  canvas.addEventListener('touchstart', e=>{
    const touches = Array.from(e.touches);
    const count = Math.min(touches.length, 3);
    if (count === 0) return;

    const h = window.innerHeight;

    for (let i=0;i<count;i++){
      const t = touches[i];
      const x = t.clientX, y = t.clientY;

      let voice, midi;
      if (y > h * (2/3)) {         // bottom third → bass
        voice = 'bass';   midi = pickBassNote();
      } else if (y > h * (1/3)) {  // middle third → mid
        voice = 'normal'; midi = pickMidNote();
      } else {                     // top third → high
        voice = 'high';   midi = pickHighNote();
      }

      addRipple(x,y,{
        opacity:0.42 + Math.random()*0.08,
        widthJitter:0.95 + Math.random()*0.4,
        life:LIFE_MS * (1.1 + Math.random()*0.25),
        speed:SPEED * (0.85 + Math.random()*0.15),
        sizeMul:1 + Math.random()*0.2,
        depth:count>1
      });

      const freq = midiToFreq(midi);
      playRippleSound(x, count>1, freq, detunesByCount[count][i] || 0, voice);
    }
  }, {passive:true});

  // Page/visibility handling + instruction fade in
  document.addEventListener('visibilitychange', ()=>{
    if (!audioCtx || !audioBooted) return;
    if (document.visibilityState === 'visible' && audioCtx.state !== 'running') {
      audioCtx.resume().catch(()=>{});
    }
  });

  // Show instructions briefly on load
  window.addEventListener('load', () => {
    if (!instrEl) return;
    instrEl.style.opacity = 1;                  // fade in
    setTimeout(() => { instrEl.style.opacity = 0; }, 6000); // fade out after 6s
  });
})();
</script>
</body>
</html>

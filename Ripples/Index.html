<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>Ripple Reveal · Ambient Minor</title>
<style>
  html,body { margin:0; height:100%; background:#000; }
  .stage { position:fixed; inset:0; overflow:hidden; }
  .bg, .bg > * { position:absolute; inset:0; width:100%; height:100%; object-fit:cover; display:block; }
  .bg { pointer-events:none; }  /* let input hit the canvas */
  canvas { position:absolute; inset:0; width:100%; height:100%; display:block; }

  #ui { position:fixed; inset:auto 0 0 auto; padding:12px; display:flex; gap:8px; align-items:center; }
  .btn {
    background:rgba(20,20,22,.5); color:#cfcfd4;
    border:1px solid rgba(255,255,255,.12);
    border-radius:6px; padding:.35rem .6rem;
    font:500 13px/1 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    cursor:pointer; backdrop-filter:blur(6px);
    transition:background .2s ease, color .2s ease, opacity .2s ease;
    opacity:.9;
  }
  .btn:hover{ background:rgba(26,26,30,.62); color:#fff; opacity:1; }
  #badge {
    font:600 11px/1 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    color:#bbb; padding:.35rem .5rem; border-radius:6px;
    background:rgba(0,0,0,.35); border:1px solid rgba(255,255,255,.12);
  }
  #badge.on { color:#7fffb2; border-color:rgba(127,255,178,.35); }
</style>
</head>
<body>
<div class="stage">
  <div class="bg">
    <!-- If this is a user/org site, change to /assets/... -->
    <video id="bgVideo" muted playsinline loop preload="auto">
      <source src="/assets/videos/Landingloop.mp4" type="video/mp4">
    </video>
  </div>
  <canvas id="c"></canvas>
</div>

<div id="ui">
  <button id="scaleBtn" class="btn">scale: pentatonicMinor</button>
  <button id="soundBtn" class="btn">sound: enable</button>
  <div id="badge">AUDIO: OFF</div>
</div>

<script>
(() => {
  // ---------------- Visuals ----------------
  const video = document.getElementById('bgVideo');
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  // Muted/minimal aesthetic
  const COVER_ALPHA=1.2, RING_COUNT=4, RING_SPACING=30, BASE_WIDTH=2, LIFE_MS=1600, SPEED=220;
  const EDGE='hsla(210,8%,80%,ALPHA)';     // cool grey-blue edge
  const SHADOW_ALPHA=0.16, SHADOW_BLUR=4, SHADOW_OFFSET_Y=1, SHADOW_WIDTH_SCALE=1.12; // subtle depth for multitouch

  let dpr = window.devicePixelRatio || 1;
  function resize(){
    const w=innerWidth, h=innerHeight;
    canvas.width=Math.floor(w*dpr);
    canvas.height=Math.floor(h*dpr);
    canvas.style.width=w+'px'; canvas.style.height=h+'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  addEventListener('resize', resize, {passive:true}); resize();

  function tryPlay(){ const p=video.play?.(); if (p?.catch) p.catch(()=>{}); }
  video.addEventListener('canplay', tryPlay);
  addEventListener('pointerdown', tryPlay, {once:true, passive:true});
  tryPlay();

  const ripples=[];
  function addRipple(x,y,opts={}){
    ripples.push({
      x,y,t0:performance.now(),
      opacity:opts.opacity ?? (0.25+Math.random()*0.5),
      widthJitter:opts.widthJitter ?? (0.8+Math.random()*0.8),
      life:opts.life ?? LIFE_MS,
      speed:opts.speed ?? SPEED,
      sizeMul:opts.sizeMul ?? 1,
      depth:!!opts.depth
    });
  }

  function frame(now){
    ctx.clearRect(0,0,canvas.width/dpr,canvas.height/dpr);
    ctx.fillStyle=`rgba(0,0,0,${COVER_ALPHA})`;
    ctx.fillRect(0,0,canvas.width/dpr,canvas.height/dpr);

    for (let i=ripples.length-1;i>=0;i--){
      const r=ripples[i], age=now-r.t0;
      if (age>r.life){ ripples.splice(i,1); continue; }
      const base=(age/1000)*r.speed;
      const life=1-age/r.life;
      const baseAlpha=r.opacity*life;
      const width=BASE_WIDTH*r.widthJitter*(1+0.25*Math.sin(age*0.005));

      // reveal
      ctx.globalCompositeOperation='destination-out';
      ctx.strokeStyle='rgba(0,0,0,1)'; ctx.lineWidth=width;
      for(let k=0;k<RING_COUNT;k++){
        const rad=(base+k*RING_SPACING)*r.sizeMul; if(rad<=0) continue;
        ctx.beginPath(); ctx.arc(r.x,r.y,rad,0,Math.PI*2); ctx.stroke();
      }

      // edge
      ctx.globalCompositeOperation='source-over';
      const edge=EDGE.replace('ALPHA',(baseAlpha*0.4).toFixed(3));
      ctx.strokeStyle=edge; ctx.lineWidth=width;
      for(let k=0;k<RING_COUNT;k++){
        const rad=(base+k*RING_SPACING)*r.sizeMul; if(rad<=0) continue;
        ctx.beginPath(); ctx.arc(r.x,r.y,rad,0,Math.PI*2); ctx.stroke();
      }

      // depth shadow for multitouch ripples
      if (r.depth && baseAlpha>0.02){
        ctx.save();
        ctx.shadowBlur=SHADOW_BLUR;
        ctx.shadowColor=`rgba(0,0,0,${(SHADOW_ALPHA*life).toFixed(3)})`;
        ctx.shadowOffsetX=0; ctx.shadowOffsetY=SHADOW_OFFSET_Y;
        ctx.strokeStyle='rgba(0,0,0,0)';
        ctx.lineWidth=width*SHADOW_WIDTH_SCALE;
        for(let k=0;k<RING_COUNT;k++){
          const rad=(base+k*RING_SPACING)*r.sizeMul; if(rad<=0) continue;
          ctx.beginPath(); ctx.arc(r.x,r.y,rad,0,Math.PI*2); ctx.stroke();
        }
        ctx.restore();
      }
    }
    ctx.globalCompositeOperation='source-over';
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  // ---------------- Audio (lazy + mobile-safe) ----------------
  const scaleBtn = document.getElementById('scaleBtn');
  const soundBtn = document.getElementById('soundBtn');
  const badge = document.getElementById('badge');

  let audioCtx = null;          // lazy-create on demand
  let audioBooted = false;

  function ensureAudioContext(){
    if (!audioCtx) {
      const AudioCtx = window.AudioContext || window.webkitAudioContext;
      audioCtx = new AudioCtx();
    }
    return audioCtx;
  }

  async function bootAudioOnce(){
    ensureAudioContext();
    if (audioBooted) return;
    try {
      if (audioCtx.state !== 'running') await audioCtx.resume();
      // 1-sample silent unlock
      const silent = audioCtx.createBuffer(1, 1, audioCtx.sampleRate);
      const src = audioCtx.createBufferSource();
      src.buffer = silent; src.connect(audioCtx.destination); src.start(0);
      audioBooted = true;
      badge.textContent = 'AUDIO: ON'; badge.classList.add('on');
      soundBtn.textContent = 'sound: enabled';
      // short confirmation ping (still subtle)
      const now = audioCtx.currentTime;
      const osc = audioCtx.createOscillator(), g = audioCtx.createGain();
      osc.type='sine'; osc.frequency.value=660;
      g.gain.setValueAtTime(0.06, now); g.gain.exponentialRampToValueAtTime(0.0001, now+0.25);
      osc.connect(g); g.connect(audioCtx.destination); osc.start(now); osc.stop(now+0.3);
    } catch(e){
      console.warn('[ripple] audio unlock failed:', e);
    }
  }

  // --- Scales (default: minor, ambient) ---
  const SCALES = {
    major:[0,2,4,5,7,9,11],
    naturalMinor:[0,2,3,5,7,8,10],
    dorian:[0,2,3,5,7,9,10],
    pentatonicMajor:[0,2,4,7,9],
    pentatonicMinor:[0,3,5,7,10], // default (ambient, fewer tones)
    lydian:[0,2,4,6,7,9,11],
    mixolydian:[0,2,4,5,7,9,10],
  };
  const scaleNames = Object.keys(SCALES);
  let currentScaleIndex = scaleNames.indexOf('pentatonicMinor'); // default minor
  let ROOT_MIDI = 50;          // D3 (lower root for nicer bass)
  let OCTAVES_UP = 2, OCTAVES_DOWN = 1; // wide but still ambient
  let SCALE = SCALES[scaleNames[currentScaleIndex]];

  function buildScalePool(rootMidi, steps, up, down){
    const pool=[]; for(let o=-down;o<=up;o++){ const base=rootMidi+12*o; for(const s of steps) pool.push(base+s); }
    return pool.sort((a,b)=>a-b);
  }
  let NOTE_POOL = buildScalePool(ROOT_MIDI, SCALE, OCTAVES_UP, OCTAVES_DOWN);

  function setScaleByName(name){
    SCALE = SCALES[name];
    NOTE_POOL = buildScalePool(ROOT_MIDI, SCALE, OCTAVES_UP, OCTAVES_DOWN);
    scaleBtn.textContent = `scale: ${name}`;
  }

  scaleBtn.addEventListener('click', () => {
    currentScaleIndex = (currentScaleIndex + 1) % scaleNames.length;
    setScaleByName(scaleNames[currentScaleIndex]);
  });

  function midiToFreq(m){ return 440 * Math.pow(2, (m-69)/12); }

  // --- Spread picker: 1 bass (low), others spread high ---
  function pickSpreadNotes(count){
    const N = NOTE_POOL.length;
    if (!N) return [];
    const lowEndIdx    = Math.max(1, Math.floor(N * 0.35));   // lower ~1/3
    const highStartIdx = Math.min(N-1, Math.floor(N * 0.55)); // upper half

    // stable bass in lower region (ambient)
    const bassIdx = Math.max(0, Math.min(lowEndIdx-1, Math.floor(N * 0.14)));
    const bass = NOTE_POOL[Math.max(0, bassIdx)];
    const notes = [bass];

    if (count === 1) return notes;

    const highs = NOTE_POOL.slice(highStartIdx);
    const voices = Math.min(count-1, 2);
    if (highs.length === 0){
      notes.push(NOTE_POOL[Math.min(N-1, Math.floor(N*0.7))]);
      if (count === 3) notes.push(NOTE_POOL[Math.min(N-1, Math.floor(N*0.9))]);
      return notes.slice(0, count);
    }
    for (let i=0;i<voices;i++){
      const pos = (i + 1) / (voices + 1); // ~even spread
      const idx = Math.min(highs.length-1, Math.floor(pos * (highs.length-1)));
      notes.push(highs[idx]);
    }
    return notes.slice(0, count);
  }

  // Play a ripple tone; supports explicit freq + tiny detune; gentle pan by x
  function playRippleSound(x, isDepth=false, freqOverride=null, detuneCents=0, isBass=false){
    if (!audioBooted) return;
    const half = Math.floor(NOTE_POOL.length/2);
    const idx = isDepth
      ? Math.floor(Math.random()*Math.max(1, half))
      : Math.floor(half + Math.random()*Math.max(1, NOTE_POOL.length-half));
    const freq = freqOverride ?? midiToFreq(NOTE_POOL[Math.min(NOTE_POOL.length-1, Math.max(0, idx))]);

    const now = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    const panner = audioCtx.createStereoPanner ? audioCtx.createStereoPanner() : null;

    osc.type='triangle';
    osc.frequency.setValueAtTime(freq, now);
    if (detuneCents) osc.detune.setValueAtTime(detuneCents, now);
    osc.frequency.linearRampToValueAtTime(freq * (isDepth ? 0.997 : 1.003), now + 0.15);

    // ambient envelope: bass a bit longer/warmer, others soft
    const startGain = isBass ? 0.06 : (isDepth ? 0.05 : 0.04);
    const dur       = isBass ? 1.8  : (isDepth ? 1.2  : 0.9);
    gain.gain.setValueAtTime(startGain, now);
    gain.gain.exponentialRampToValueAtTime(0.0001, now + dur);

    if (panner){
      const pan = (x / window.innerWidth) * 2 - 1;
      panner.pan.setValueAtTime((isBass ? 0.2 : 0.6) * pan, now); // keep bass more centered
      osc.connect(gain); gain.connect(panner); panner.connect(audioCtx.destination);
    } else { osc.connect(gain); gain.connect(audioCtx.destination); }

    osc.start(now); osc.stop(now + dur + 0.1);
  }

  // ---------------- Input (with audio unlock hooks) ----------------
  soundBtn.addEventListener('click', bootAudioOnce, { passive:true });
  addEventListener('pointerdown', bootAudioOnce, { once:true, passive:true });
  addEventListener('touchstart',  bootAudioOnce, { once:true, passive:true });

  // Mouse / single
  canvas.addEventListener('pointerdown', e=>{
    if (e.touches) return;
    const x=e.clientX, y=e.clientY;
    addRipple(x,y);
    playRippleSound(x, false);
  }, {passive:true});

  // Touch: 1–3 fingers -> leftmost is bass, others spread high
  canvas.addEventListener('touchstart', e=>{
    const touches = Array.from(e.touches);
    const count = Math.min(touches.length, 3);
    if (count===0) return;

    // Leftmost as bass anchor
    touches.sort((a,b)=>a.clientX - b.clientX);

    const notes = pickSpreadNotes(count);
    const detunesByCount = { 1:[0], 2:[-2,+2], 3:[-3,0,+3] };

    for (let i=0;i<count;i++){
      const t = touches[i];
      const x=t.clientX, y=t.clientY;
      const isBass = (i===0 && count>=2);

      addRipple(x,y,{
        opacity: isBass ? 0.5 : (0.42 + Math.random()*0.08),
        widthJitter: 0.95 + Math.random()*0.4,
        life: (isBass ? LIFE_MS*1.35 : LIFE_MS * (1.1 + Math.random()*0.25)),
        speed: SPEED * (isBass ? 0.8 : (0.85 + Math.random()*0.15)),
        sizeMul: 1 + Math.random()*0.2,
        depth: count>1
      });

      const midi = notes[i];
      const freq = midiToFreq(midi);
      playRippleSound(x, count>1, freq, detunesByCount[count][i] || 0, isBass);
    }
  }, {passive:true});

  // If Safari suspends when tabbed out, resume on return
  document.addEventListener('visibilitychange', ()=>{
    if (!audioCtx || !audioBooted) return;
    if (document.visibilityState === 'visible' && audioCtx.state !== 'running') {
      audioCtx.resume().catch(()=>{});
    }
  });
})();
</script>
</body>
</html>

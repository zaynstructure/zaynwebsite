<script>
  // ============================================================
  // EVF GEOMETRY · DEV NOTES
  // ------------------------------------------------------------
  // - This tool visualizes an Emotional Vector Field (EVF) as a
  //   7-axis polygon: damping, coupling, noise, rhythm, gradient,
  //   attractor, coherence.
  //
  // - Parameters live in `state[param]` on a 0–10 scale.
  //   Geometry = normalized radii of these 7 values.
  //
  // - Self-assessment is multi-item per parameter:
  //     * each item rated 0–4 (Likert)
  //     * items are intentionally parallel for that parameter
  //     * no psychometric factor analysis yet
  //
  // - IMPORTANT: all items are equally weighted on purpose.
  //   There is no empirical basis (yet) for differential weighting.
  //   This keeps the mapping transparent and conceptually honest.
  //
  //   Pipeline:
  //     raw (0–4) -> normalize to 0–1 (with optional reversal)
  //     -> mean across items for that param -> scale to 0–10
  //
  // - If future data suggests different item discrimination, you
  //   can add a `weight` field to ASSESSMENT_ITEMS and change the
  //   aggregation in `applyAssessmentBtn` without touching any
  //   geometry logic.
  // ============================================================

  // ---------- config ----------
  const PARAM_ORDER = [
    'damping','coupling','noise','rhythm','gradient','attractor','coherence'
  ];
  const PARAM_LABELS = {
    damping:'damping',
    coupling:'coupling',
    noise:'noise',
    rhythm:'rhythm',
    gradient:'gradient',
    attractor:'attractor',
    coherence:'coherence'
  };

  // ------------------------------------------------------------
  // ASSESSMENT ITEMS · DEV NOTES
  // ------------------------------------------------------------
  // - Each item belongs to exactly one EVF parameter (param).
  // - `reverse: true` means higher agreement should REDUCE the
  //   parameter rather than increase it.
  //   Example:
  //     noise item "It is easy to find a quiet channel" is reverse.
  //
  // - Equal-weight design:
  //     * For now, every item contributes equally.
  //     * This is conceptually aligned with EVF: we're building a
  //       reflective geometry, not a diagnostic scale.
  //
  // - If you later want weights:
  //     * add `weight: 1.0` to each item
  //     * adjust the aggregation in applyAssessmentBtn to use
  //       weighted means.
  // ------------------------------------------------------------
  const ASSESSMENT_ITEMS = [
    // damping
    { id:'d1', param:'damping', reverse:false,
      text:'When I get emotionally activated, I can usually settle or calm down within a reasonable time.' },
    { id:'d2', param:'damping', reverse:true,
      text:'Emotions tend to linger in my body for a long time before easing.' },

    // coupling
    { id:'c1', param:'coupling', reverse:false,
      text:'Other people’s moods strongly affect my own mood.' },
    { id:'c2', param:'coupling', reverse:true,
      text:'I feel mostly insulated from other people’s emotional states.' },

    // noise
    { id:'n1', param:'noise', reverse:false,
      text:'My mind feels cluttered or noisy lately.' },
    { id:'n2', param:'noise', reverse:true,
      text:'It is easy for me to find a quiet, clear channel in my thoughts.' },

    // rhythm
    { id:'r1', param:'rhythm', reverse:false,
      text:'My days follow a fairly steady rhythm (sleep, meals, activity, rest).' },
    { id:'r2', param:'rhythm', reverse:true,
      text:'My routines feel all over the place or unpredictable.' },

    // gradient
    { id:'g1', param:'gradient', reverse:false,
      text:'I feel a clear sense of direction or pull toward something meaningful.' },
    { id:'g2', param:'gradient', reverse:true,
      text:'It is hard to care enough about anything to move toward it.' },

    // attractor
    { id:'a1', param:'attractor', reverse:false,
      text:'One theme, worry, or goal takes up a lot of my mental space.' },
    { id:'a2', param:'attractor', reverse:true,
      text:'My attention feels scattered rather than anchored to anything in particular.' },

    // coherence
    { id:'h1', param:'coherence', reverse:false,
      text:'My life and emotions make sense to me as a mostly coherent story.' },
    { id:'h2', param:'coherence', reverse:true,
      text:'Different parts of my life feel fragmented or contradictory.' }
  ];

  const MAX_SCALE = 10;
  const BASE_RADIUS = 120;

  const state = {
    damping:4, coupling:6, noise:5, rhythm:3,
    gradient:5, attractor:7, coherence:4
  };

  // ---------- DOM refs ----------
  const canvas       = document.getElementById('evfCanvas');
  const ctx          = canvas.getContext('2d');
  const spikinessEl  = document.getElementById('spikinessValue');
  const avgRadiusEl  = document.getElementById('avgRadiusValue');
  const notesListEl  = document.getElementById('notesList');
  const badgeEl      = document.getElementById('balanceBadge');
  const domLabelEl   = document.getElementById('dominantLabel');
  const exportSvgBtn = document.getElementById('exportSvgBtn');
  const resetBtn     = document.getElementById('resetBtn');

  const assessmentContainer = document.getElementById('assessment');
  const applyAssessmentBtn  = document.getElementById('applyAssessmentBtn');
  const advancedToggle      = document.getElementById('advancedToggle');
  const advancedPanel       = document.getElementById('advancedPanel');
  const slidersContainer    = document.getElementById('sliders');

  const infoBtn           = document.getElementById('infoBtn');
  const infoModalBackdrop = document.getElementById('infoModalBackdrop');
  const infoModalClose    = document.getElementById('infoModalClose');

  const itemInputs = {};  // ASSESSMENT_ITEMS id -> input
  const inputs     = {};  // PARAM_ORDER name -> slider input
  let lastResult   = null;
  let advancedVisible = false;

  // ---------- helpers ----------
  function clamp(v,min,max){ return Math.min(max,Math.max(min,v)); }
  function mean(a){ return a.length ? a.reduce((x,y)=>x+y,0)/a.length : 0; }
  function variance(a,m){ if(!a.length) return 0; const mm=m??mean(a); return mean(a.map(v=>(v-mm)**2)); }

  // ---------- EVF analysis ----------
  function analyzeEVFState(s, {order=PARAM_ORDER,maxScale=MAX_SCALE,baseRadius=BASE_RADIUS}={}) {
    const n = order.length;
    const vertices = [];
    for (let i=0;i<n;i++){
      const name = order[i];
      const raw  = clamp(s[name]??0,0,maxScale);
      const norm = raw/maxScale;
      const angle = (i/n)*Math.PI*2;
      const r = norm*baseRadius;
      const x = r*Math.cos(angle);
      const y = r*Math.sin(angle);
      vertices.push({name,raw,normalized:norm,angleRad:angle,r,x,y});
    }
    const sx = vertices.reduce((sum,v)=>sum+v.x,0);
    const sy = vertices.reduce((sum,v)=>sum+v.y,0);
    const centroid = { x: sx/vertices.length, y: sy/vertices.length };
    const radii = vertices.map(v=>v.r);
    const avgR = mean(radii);
    const varR = variance(radii,avgR);
    const spikiness = Math.sqrt(varR)/(baseRadius||1);
    const notes = interpretPattern(s,{maxScale});
    const dominantSpikes = getDominantSpikes(vertices);
    return { vertices, centroid, avgRadius:avgR, varianceRadius:varR, spikiness, dominantSpikes, notes };
  }

  function getDominantSpikes(vertices){
    if(!vertices.length) return [];
    const radii = vertices.map(v=>v.r);
    const m  = mean(radii);
    const sd = Math.sqrt(variance(radii,m))||1;
    const thresh = m + 0.7*sd;
    return vertices.filter(v=>v.r>thresh).map(v=>v.name);
  }

  function interpretPattern(s,{maxScale}){
    const norm = k => (s[k]??0)/(maxScale||10);
    const d=norm('damping'), c=norm('coupling'), n=norm('noise'),
          r=norm('rhythm'), g=norm('gradient'),
          a=norm('attractor'), h=norm('coherence');
    const notes=[];
    if(c>0.7 && d<0.5) notes.push('strong pull from others / environment, low self-buffering');
    if(a>0.7 && g>0.6 && d<0.4) notes.push('driven toward something with little braking power');
    if(n>0.6 && h<0.4) notes.push('fragmented field: high noise with low coherence');
    if(h>0.6 && r>0.4 && r<0.8) notes.push('organized pattern with workable rhythms');
    if(g<0.3 && r<0.3) notes.push('low drive and weak rhythms – risk of stagnation');
    if(!notes.length) notes.push('mixed pattern without a single dominant imbalance');
    return notes;
  }

  // ---------- UI build: assessment ----------
  function createAssessment() {
    // group items by parameter so we can show small headings
    const groupOrder = PARAM_ORDER;
    const grouped = {};
    ASSESSMENT_ITEMS.forEach(item => {
      if (!grouped[item.param]) grouped[item.param] = [];
      grouped[item.param].push(item);
    });

    groupOrder.forEach(param => {
      if (!grouped[param]) return;
      const groupTitle = document.createElement('div');
      groupTitle.className = 'item-group-title';
      groupTitle.textContent = param;
      assessmentContainer.appendChild(groupTitle);

      grouped[param].forEach(item => {
        const row = document.createElement('div');
        row.className = 'item-row';

        const text = document.createElement('div');
        text.className = 'item-text';
        text.textContent = item.text;

        const ctrl = document.createElement('div');
        ctrl.className = 'item-control-row';

        const labelLow = document.createElement('span');
        labelLow.className = 'item-label';
        labelLow.textContent = '0';

        const slider = document.createElement('input');
        slider.type = 'range';
        slider.min = '0';
        slider.max = '4';
        slider.step = '1';
        slider.value = '2'; // neutral
        slider.className = 'item-slider';

        const valueSpan = document.createElement('span');
        valueSpan.className = 'item-value';
        valueSpan.textContent = slider.value;

        slider.addEventListener('input', () => {
          valueSpan.textContent = slider.value;
        });

        itemInputs[item.id] = slider;

        ctrl.appendChild(labelLow);
        ctrl.appendChild(slider);
        ctrl.appendChild(valueSpan);

        row.appendChild(text);
        row.appendChild(ctrl);
        assessmentContainer.appendChild(row);
      });
    });
  }

  // ---------- UI build: advanced sliders ----------
  function createSliders() {
    PARAM_ORDER.forEach(name => {
      const row = document.createElement('div');
      row.className = 'slider-row';

      const label = document.createElement('label');
      label.textContent = PARAM_LABELS[name];

      const input = document.createElement('input');
      input.type = 'range';
      input.min = '0';
      input.max = String(MAX_SCALE);
      input.step = '1';
      input.value = String(state[name] ?? 0);
      inputs[name] = input;

      const valueSpan = document.createElement('span');
      valueSpan.className = 'slider-value';
      valueSpan.textContent = input.value;

      input.addEventListener('input', () => {
        state[name] = Number(input.value);
        valueSpan.textContent = input.value;
        update();
      });

      row.appendChild(label);
      row.appendChild(input);
      row.appendChild(valueSpan);
      slidersContainer.appendChild(row);
    });
  }

  // ---------- canvas ----------
  function resizeCanvas(){
    const rect = canvas.getBoundingClientRect();
    canvas.width  = rect.width * window.devicePixelRatio;
    canvas.height = rect.height * window.devicePixelRatio;
    ctx.setTransform(window.devicePixelRatio,0,0,window.devicePixelRatio,0,0);
  }

  window.addEventListener('resize', () => {
    resizeCanvas();
    update();
  });

  function drawGeometry(result){
    const {vertices,centroid,spikiness} = result;
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    const cx = w/2, cy = h/2;
    ctx.clearRect(0,0,w,h);
    ctx.save();
    ctx.translate(cx,cy);

    const rings=4;
    const maxR = Math.min(w,h)*0.36;
    ctx.strokeStyle='rgba(148,163,184,0.15)';
    ctx.lineWidth=1;
    for(let i=1;i<=rings;i++){
      const r=(i/rings)*maxR;
      ctx.beginPath();
      ctx.arc(0,0,r,0,Math.PI*2);
      ctx.stroke();
    }

    ctx.font='10px system-ui';
    ctx.fillStyle='rgba(148,163,184,0.85)';
    ctx.textAlign='center';
    ctx.textBaseline='middle';
    vertices.forEach(v=>{
      const axisR=maxR+12;
      const ax=axisR*Math.cos(v.angleRad);
      const ay=axisR*Math.sin(v.angleRad);
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.lineTo(ax,ay);
      ctx.strokeStyle='rgba(51,65,85,0.7)';
      ctx.stroke();
      const lx=(axisR+14)*Math.cos(v.angleRad);
      const ly=(axisR+14)*Math.sin(v.angleRad);
      ctx.fillText(v.name,lx,ly);
    });

    const scale=maxR/BASE_RADIUS;
    ctx.beginPath();
    vertices.forEach((v,i)=>{
      const x=v.x*scale, y=v.y*scale;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    });
    ctx.closePath();
    const intensity=Math.min(1,spikiness*2.2);
    const baseAlpha=0.18+intensity*0.15;
    ctx.fillStyle=`rgba(56,189,248,${baseAlpha})`;
    ctx.strokeStyle='rgba(56,189,248,0.8)';
    ctx.lineWidth=2;
    ctx.fill();
    ctx.stroke();

    ctx.beginPath();
    ctx.arc(centroid.x*scale,centroid.y*scale,3.5,0,Math.PI*2);
    ctx.fillStyle='#e5e7eb';
    ctx.fill();
    ctx.restore();
  }

  // ---------- SVG export ----------
  function buildSVG(result,{width=600,height=600}={}){
    const cx=width/2, cy=height/2;
    const maxR=Math.min(width,height)*0.36;
    const scale=maxR/BASE_RADIUS;
    const {vertices,centroid} = result;
    let rings='';
    const ringCount=4;
    for(let i=1;i<=ringCount;i++){
      const r=(i/ringCount)*maxR;
      rings+=`<circle cx="${cx}" cy="${cy}" r="${r.toFixed(2)}" fill="none" stroke="#1f2937" stroke-width="1"/>\n`;
    }
    let axes='';
    vertices.forEach(v=>{
      const axisR=maxR+12;
      const ax=cx+axisR*Math.cos(v.angleRad);
      const ay=cy+axisR*Math.sin(v.angleRad);
      const lx=cx+(axisR+14)*Math.cos(v.angleRad);
      const ly=cy+(axisR+14)*Math.sin(v.angleRad);
      axes+=`<line x1="${cx}" y1="${cy}" x2="${ax.toFixed(2)}" y2="${ay.toFixed(2)}" stroke="#1f2937" stroke-width="1"/>\n`;
      axes+=`<text x="${lx.toFixed(2)}" y="${ly.toFixed(2)}" fill="#9ca3af" font-size="11" text-anchor="middle" dominant-baseline="middle">${v.name}</text>\n`;
    });
    const points = vertices.map(v=>{
      const px=cx+v.x*scale, py=cy+v.y*scale;
      return `${px.toFixed(2)},${py.toFixed(2)}`;
    }).join(' ');
    const centroidX=cx+centroid.x*scale;
    const centroidY=cy+centroid.y*scale;

    return `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">
  <rect x="0" y="0" width="${width}" height="${height}" fill="#020617"/>
  <g>
    ${rings}
    ${axes}
    <polygon points="${points}" fill="rgba(56,189,248,0.24)" stroke="#38bdf8" stroke-width="2"/>
    <circle cx="${centroidX.toFixed(2)}" cy="${centroidY.toFixed(2)}" r="4" fill="#e5e7eb"/>
  </g>
</svg>`;
  }

  function downloadSVG(result){
    const svg=buildSVG(result,{width:600,height:600});
    const blob=new Blob([svg],{type:'image/svg+xml;charset=utf-8'});
    const url=URL.createObjectURL(blob);
    const a=document.createElement('a');
    a.href=url; a.download='evf-geometry.svg';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  // ---------- update ----------
  function update(){
    const result = analyzeEVFState(state,{maxScale:MAX_SCALE,baseRadius:BASE_RADIUS});
    lastResult = result;
    drawGeometry(result);
    spikinessEl.textContent = result.spikiness.toFixed(2);
    avgRadiusEl.textContent = result.avgRadius.toFixed(1);

    const s = result.spikiness;
    if (s < 0.12) {
      badgeEl.textContent = 'pattern: smooth / balanced';
      badgeEl.classList.remove('alert');
    } else if (s < 0.22) {
      badgeEl.textContent = 'pattern: moderately uneven';
      badgeEl.classList.remove('alert');
    } else {
      badgeEl.textContent = 'pattern: jagged / polarized';
      badgeEl.classList.add('alert');
    }

    domLabelEl.textContent = result.dominantSpikes.length
      ? 'dominant: ' + result.dominantSpikes.join(', ')
      : '';

    notesListEl.innerHTML='';
    result.notes.forEach(t=>{
      const li=document.createElement('li');
      li.textContent=t;
      notesListEl.appendChild(li);
    });
  }

  // ---------- interactions ----------
  resetBtn.addEventListener('click',()=>{
    // neutral-ish state
    PARAM_ORDER.forEach(name=>{
      state[name]=5;
      if(inputs[name]){
        inputs[name].value='5';
        inputs[name].nextSibling.textContent='5';
      }
    });
    // center assessment sliders at 2 (neutral)
    ASSESSMENT_ITEMS.forEach(item=>{
      const inp = itemInputs[item.id];
      if (inp) inp.value = '2';
    });
    update();
  });

  exportSvgBtn.addEventListener('click',()=>{
    if(!lastResult){
      lastResult=analyzeEVFState(state,{maxScale:MAX_SCALE,baseRadius:BASE_RADIUS});
    }
    downloadSVG(lastResult);
  });

  // ------------------------------------------------------------
  // APPLY ASSESSMENT · DEV NOTES
  // ------------------------------------------------------------
  // Mapping pipeline:
  //   1. Each slider is 0–4.
  //   2. If reverse == true, we flip: norm = (4 - raw)/4.
  //   3. Otherwise, norm = raw/4. Now everything is 0–1 where
  //      higher = "more of the parameter" as conceptually defined.
  //   4. For each parameter, we average its item norms (equal
  //      weight -> simple mean).
  //   5. We scale 0–1 -> 0–10 and round to an integer.
  //
  // This keeps:
  //   - a transparent relationship between items and geometry
  //   - easy swap-out of items without math surgery
  //   - room for future weighting if justified by data
  // ------------------------------------------------------------
  applyAssessmentBtn.addEventListener('click',()=>{
    // compute param scores from multi-item responses
    const sums = {};
    const counts = {};
    PARAM_ORDER.forEach(p => { sums[p]=0; counts[p]=0; });

    ASSESSMENT_ITEMS.forEach(item=>{
      const inp = itemInputs[item.id];
      if (!inp) return;
      const raw = Number(inp.value)||0; // 0..4
      const norm = item.reverse ? (4-raw)/4 : raw/4; // 0..1
      sums[item.param] += norm;
      counts[item.param] += 1;
    });

    PARAM_ORDER.forEach(param=>{
      if (counts[param] > 0) {
        const avgNorm = sums[param] / counts[param]; // 0..1
        const scaled  = Math.round(avgNorm * MAX_SCALE); // 0..10
        state[param] = scaled;
        if (inputs[param]) {
          inputs[param].value = String(scaled);
          inputs[param].nextSibling.textContent = String(scaled);
        }
      }
    });

    update();
  });

  advancedToggle.addEventListener('click',()=>{
    advancedVisible = !advancedVisible;
    advancedPanel.style.display = advancedVisible ? 'block' : 'none';
    advancedToggle.textContent = advancedVisible
      ? 'hide advanced parameters (manual override)'
      : 'show advanced parameters (manual override)';
  });

  // info modal
  infoBtn.addEventListener('click',()=>{
    infoModalBackdrop.style.display='flex';
  });
  infoModalClose.addEventListener('click',()=>{
    infoModalBackdrop.style.display='none';
  });
  infoModalBackdrop.addEventListener('click',(e)=>{
    if(e.target === infoModalBackdrop){
      infoModalBackdrop.style.display='none';
    }
  });

  // ---------- init ----------
  createAssessment();
  createSliders();
  resizeCanvas();
  update();
</script>

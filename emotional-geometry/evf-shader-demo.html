<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>EVF Shader Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: #020617;
      color: #e5e7eb;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    #controls {
      padding: 8px 10px;
      font-size: 11px;
      background: #020617;
      border-bottom: 1px solid #111827;
      display: flex;
      flex-wrap: wrap;
      gap: 6px 12px;
      align-items: center;
    }
    .label {
      display: flex;
      align-items: center;
      gap: 4px;
      color: #9ca3af;
    }
    .label span.name {
      width: 70px;
      text-transform: lowercase;
    }
    .label input[type="range"] {
      width: 120px;
    }
    #glWrap {
      flex: 1;
      position: relative;
    }
    #glCanvas {
      width: 100%;
      height: 100%;
      display: block;
    }
  </style>
</head>
<body>
<div id="controls">
  <span style="font-weight:600;margin-right:8px;">EVF demo</span>
  <label class="label">
    <span class="name">damping</span>
    <input id="damping" type="range" min="0" max="1" step="0.01" value="0.4">
  </label>
  <label class="label">
    <span class="name">coupling</span>
    <input id="coupling" type="range" min="0" max="1" step="0.01" value="0.7">
  </label>
  <label class="label">
    <span class="name">noise</span>
    <input id="noise" type="range" min="0" max="1" step="0.01" value="0.5">
  </label>
  <label class="label">
    <span class="name">rhythm</span>
    <input id="rhythm" type="range" min="0" max="1" step="0.01" value="0.6">
  </label>
  <label class="label">
    <span class="name">gradient</span>
    <input id="gradient" type="range" min="0" max="1" step="0.01" value="0.6">
  </label>
  <label class="label">
    <span class="name">attractor</span>
    <input id="attractor" type="range" min="0" max="1" step="0.01" value="0.7">
  </label>
  <label class="label">
    <span class="name">coherence</span>
    <input id="coherence" type="range" min="0" max="1" step="0.01" value="0.5">
  </label>
</div>

<div id="glWrap">
  <canvas id="glCanvas"></canvas>
</div>

<script>
  const canvas = document.getElementById('glCanvas');
  const gl = canvas.getContext('webgl');
  if (!gl) {
    alert('WebGL not supported');
  }

  function resize() {
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    const w = rect.width * dpr;
    const h = rect.height * dpr;
    if (canvas.width !== w || canvas.height !== h) {
      canvas.width = w;
      canvas.height = h;
      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
    }
  }
  window.addEventListener('resize', resize);

  const vsSource = `
    attribute vec2 aPosition;
    void main() {
      gl_Position = vec4(aPosition, 0.0, 1.0);
    }
  `;

  const fsSource = `
    precision highp float;

    uniform float uDamping;    // 0..1
    uniform float uCoupling;   // 0..1
    uniform float uNoise;      // 0..1
    uniform float uRhythm;     // 0..1
    uniform float uGradient;   // 0..1
    uniform float uAttractor;  // 0..1
    uniform float uCoherence;  // 0..1

    uniform vec2  uResolution;
    uniform float uTime;

    float hash(vec2 p) {
        return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
    }

    float noise2D(vec2 p) {
        vec2 i = floor(p);
        vec2 f = fract(p);
        float a = hash(i);
        float b = hash(i + vec2(1.0, 0.0));
        float c = hash(i + vec2(0.0, 1.0));
        float d = hash(i + vec2(1.0, 1.0));

        vec2 u = f * f * (3.0 - 2.0 * f);
        return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
    }

    // WebGL1-safe "tanh" approximation
    float softsign(float x) {
        return x / (1.0 + abs(x));
    }

    void main() {
        vec2 uv = (gl_FragCoord.xy / uResolution.xy) * 2.0 - 1.0;
        uv.x *= uResolution.x / uResolution.y;

        // coherence: blend with mirrored x
        vec2 uvSym = vec2(-uv.x, uv.y);
        uv = mix(uv, uvSym, uCoherence * 0.5);

        // gradient direction
        vec2 gDir = normalize(vec2(0.7, -0.4));
        float slope = dot(uv, gDir);
        float gradField = slope * (0.5 + 1.5 * uGradient);

        // attractor at bottom-right-ish
        vec2 attractPos = vec2(0.5, -0.4);
        float distA = length(uv - attractPos);
        float attractField = exp(-distA * (2.0 + 6.0 * (1.0 - uAttractor)));

        // coupling as cell clustering
        vec2 cellScale = mix(vec2(12.0, 8.0), vec2(3.0, 3.0), uCoupling);
        vec2 cell = floor(uv * cellScale);
        float cellHash = hash(cell);
        float clusterField = mix(0.0, cellHash, uCoupling);

        // noise
        float baseNoise = noise2D(uv * mix(3.0, 15.0, uNoise) + uTime * 0.15);
        float spikeNoise = pow(baseNoise, mix(2.0, 0.4, uNoise));
        float noiseField = mix(0.0, spikeNoise, uNoise);

        // rhythm stripes
        float stripeFreq = mix(0.0, 12.0, uRhythm);
        float stripes = 0.0;
        if (stripeFreq > 0.0) {
            stripes = 0.5 + 0.5 * sin(uv.y * stripeFreq + uTime * 0.7);
        }

        // combine
        float field =
            0.7 * gradField +
            1.4 * attractField +
            0.8 * clusterField +
            0.7 * stripes +
            0.9 * noiseField;

        // damping = contrast softener
        float contrast = mix(1.8, 0.7, uDamping);
        field = softsign(field * contrast);

        // palette (friendly-geometry-ish)
        vec3 baseA = vec3(0.12, 0.16, 0.24);
        vec3 baseB = vec3(0.87, 0.80, 0.72);
        vec3 accent = vec3(0.40, 0.74, 0.86);

        float t = clamp(0.5 + 0.5 * field, 0.0, 1.0);
        vec3 col = mix(baseA, baseB, t);
        col = mix(col, accent, attractField * 0.6);

        // vignette
        float vignette = smoothstep(1.4, 0.6, length(uv));
        col *= vignette;

        gl_FragColor = vec4(col, 1.0);
    }
  `;

  function compileShader(gl, type, source) {
    const s = gl.createShader(type);
    gl.shaderSource(s, source);
    gl.compileShader(s);
    if (!gl.getShaderParameter(s, gl.COMPLETE_STATUS) &&
        !gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
      console.error(gl.getShaderInfoLog(s));
      gl.deleteShader(s);
      return null;
    }
    return s;
  }

  function createProgram(gl, vsSource, fsSource) {
    const vs = compileShader(gl, gl.VERTEX_SHADER, vsSource);
    const fs = compileShader(gl, gl.FRAGMENT_SHADER, fsSource);
    const prog = gl.createProgram();
    gl.attachShader(prog, vs);
    gl.attachShader(prog, fs);
    gl.linkProgram(prog);
    if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
      console.error(gl.getProgramInfoLog(prog));
      gl.deleteProgram(prog);
      return null;
    }
    return prog;
  }

  const program = createProgram(gl, vsSource, fsSource);
  gl.useProgram(program);

  const positionLoc = gl.getAttribLocation(program, 'aPosition');
  const uDampingLoc   = gl.getUniformLocation(program, 'uDamping');
  const uCouplingLoc  = gl.getUniformLocation(program, 'uCoupling');
  const uNoiseLoc     = gl.getUniformLocation(program, 'uNoise');
  const uRhythmLoc    = gl.getUniformLocation(program, 'uRhythm');
  const uGradientLoc  = gl.getUniformLocation(program, 'uGradient');
  const uAttractorLoc = gl.getUniformLocation(program, 'uAttractor');
  const uCoherenceLoc = gl.getUniformLocation(program, 'uCoherence');
  const uResolutionLoc= gl.getUniformLocation(program, 'uResolution');
  const uTimeLoc      = gl.getUniformLocation(program, 'uTime');

  // fullscreen quad
  const quadBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
  const quadVerts = new Float32Array([
    -1, -1,
     1, -1,
    -1,  1,
    -1,  1,
     1, -1,
     1,  1
  ]);
  gl.bufferData(gl.ARRAY_BUFFER, quadVerts, gl.STATIC_DRAW);

  gl.enableVertexAttribArray(positionLoc);
  gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

  const sliders = {
    damping:   document.getElementById('damping'),
    coupling:  document.getElementById('coupling'),
    noise:     document.getElementById('noise'),
    rhythm:    document.getElementById('rhythm'),
    gradient:  document.getElementById('gradient'),
    attractor: document.getElementById('attractor'),
    coherence: document.getElementById('coherence')
  };

  const start = performance.now();

  function render() {
    resize();

    const t = (performance.now() - start) / 1000;

    gl.useProgram(program);
    gl.uniform2f(uResolutionLoc, gl.drawingBufferWidth, gl.drawingBufferHeight);
    gl.uniform1f(uTimeLoc, t);

    gl.uniform1f(uDampingLoc,   parseFloat(sliders.damping.value));
    gl.uniform1f(uCouplingLoc,  parseFloat(sliders.coupling.value));
    gl.uniform1f(uNoiseLoc,     parseFloat(sliders.noise.value));
    gl.uniform1f(uRhythmLoc,    parseFloat(sliders.rhythm.value));
    gl.uniform1f(uGradientLoc,  parseFloat(sliders.gradient.value));
    gl.uniform1f(uAttractorLoc, parseFloat(sliders.attractor.value));
    gl.uniform1f(uCoherenceLoc, parseFloat(sliders.coherence.value));

    gl.drawArrays(gl.TRIANGLES, 0, 6);

    requestAnimationFrame(render);
  }

  resize();
  render();
</script>
</body>
</html>

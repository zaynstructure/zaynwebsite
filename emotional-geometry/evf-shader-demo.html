<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>EVF Shader Demo · Inverted + Particles</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: #020617;
      color: #e5e7eb;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    #controls {
      padding: 8px 10px;
      font-size: 11px;
      background: #020617;
      border-bottom: 1px solid #111827;
      display: flex;
      flex-wrap: wrap;
      gap: 6px 12px;
      align-items: center;
    }
    .label {
      display: flex;
      align-items: center;
      gap: 4px;
      color: #9ca3af;
    }
    .label span.name {
      width: 70px;
      text-transform: lowercase;
    }
    .label input[type="range"] {
      width: 120px;
    }
    #glWrap {
      flex: 1;
      position: relative;
    }
    #glCanvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    #particles {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      display: block;
    }
  </style>
</head>
<body>
<div id="controls">
  <span style="font-weight:600;margin-right:8px;">EVF field demo</span>

  <label class="label"><span class="name">damping</span>
    <input id="damping" type="range" min="0" max="1" step="0.01" value="0.4">
  </label>
  <label class="label"><span class="name">coupling</span>
    <input id="coupling" type="range" min="0" max="1" step="0.01" value="0.7">
  </label>
  <label class="label"><span class="name">noise</span>
    <input id="noise" type="range" min="0" max="1" step="0.01" value="0.5">
  </label>
  <label class="label"><span class="name">rhythm</span>
    <input id="rhythm" type="range" min="0" max="1" step="0.01" value="0.6">
  </label>
  <label class="label"><span class="name">gradient</span>
    <input id="gradient" type="range" min="0" max="1" step="0.01" value="0.6">
  </label>
  <label class="label"><span class="name">attractor</span>
    <input id="attractor" type="range" min="0" max="1" step="0.01" value="0.7">
  </label>
  <label class="label"><span class="name">coherence</span>
    <input id="coherence" type="range" min="0" max="1" step="0.01" value="0.5">
  </label>
</div>

<div id="glWrap">
  <canvas id="glCanvas"></canvas>
  <canvas id="particles"></canvas>
</div>

<script>
  // ------------------ WEBGL SETUP ------------------
  const canvas = document.getElementById('glCanvas');
  const gl = canvas.getContext('webgl');
  if (!gl) { alert('WebGL not supported'); }

  function resizeGL() {
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    const w = rect.width * dpr, h = rect.height * dpr;
    if (canvas.width !== w || canvas.height !== h) {
      canvas.width = w; canvas.height = h;
      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
    }
  }
  window.addEventListener('resize', () => resizeGL());

  const vsSource = `attribute vec2 aPosition;
    void main() { gl_Position = vec4(aPosition, 0.0, 1.0); }`;

  // ------------------ EVF SHADER (inverted colors) ------------------
  const fsSource = `
    precision highp float;

    uniform float uDamping, uCoupling, uNoise, uRhythm;
    uniform float uGradient, uAttractor, uCoherence;
    uniform vec2  uResolution;
    uniform float uTime;

    float hash(vec2 p){ return fract(sin(dot(p, vec2(127.1,311.7))) * 43758.5453); }

    float noise(vec2 p){
        vec2 i=floor(p), f=fract(p);
        float a=hash(i);
        float b=hash(i+vec2(1,0));
        float c=hash(i+vec2(0,1));
        float d=hash(i+vec2(1,1));
        vec2 u=f*f*(3.0-2.0*f);
        return mix(mix(a,b,u.x), mix(c,d,u.x), u.y);
    }

    float soft(float x){ return x/(1.0+abs(x)); }

    void main(){
        vec2 uv = (gl_FragCoord.xy/uResolution.xy)*2.0 - 1.0;
        uv.x *= uResolution.x / uResolution.y;

        vec2 p = uv * 1.7;

        // coherence: mirroring
        vec2 p2 = vec2(-p.x, p.y);
        p = mix(p, p2, uCoherence * 0.5);

        // gradient
        vec2 gdir = normalize(vec2(0.7,-0.4));
        float grad = dot(p,gdir) * (1.0 + 2.0*uGradient);

        // attractor
        vec2 aPos = vec2(0.5,-0.5);
        float dA = length(p - aPos);
        float attract = exp(-dA * (1.5 + 4.0*(1.0-uAttractor)));

        // facets (polygon clusters via Voronoi)
        float cellScale = mix(10.0, 5.0, uCoupling);
        float edges = 0.0;
        {
          vec2 g = floor(p*cellScale);
          float d = 1.0;
          for(int y=-1;y<=1;y++){
            for(int x=-1;x<=1;x++){
              vec2 o = vec2(x,y);
              vec2 r = g + o + noise(g+o);
              d = min(d, length(r/cellScale - p));
            }
          }
          edges = smoothstep(0.0,0.55,d);
        }

        // turbulence
        float turb = noise(p * mix(3.0,18.0,uNoise) + uTime*0.2);

        float field =
            grad * 1.0 +
            attract * 1.5 +
            (1.0 - edges) * uCoupling * 1.0 +
            turb * 1.0;

        float contrast = mix(2.0, 0.7, uDamping);
        float h = soft(field * contrast);

        vec3 deep = vec3(0.08,0.12,0.19);
        vec3 beige = vec3(0.90,0.83,0.75);

        vec3 col = mix(deep, beige, 0.5 + 0.5*h);

        // invert colors
        col = 1.0 - col;

        gl_FragColor = vec4(col,1.0);
    }
  `;

  function compileShader(gl, type, src) {
    const s = gl.createShader(type);
    gl.shaderSource(s, src); gl.compileShader(s);
    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
      console.error(gl.getShaderInfoLog(s)); return null;
    }
    return s;
  }

  function createProgram(gl, vs, fs) {
    const p = gl.createProgram();
    gl.attachShader(p, compileShader(gl, gl.VERTEX_SHADER, vs));
    gl.attachShader(p, compileShader(gl, gl.FRAGMENT_SHADER, fs));
    gl.linkProgram(p);
    if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
      console.error(gl.getProgramInfoLog(p)); return null;
    }
    return p;
  }

  const program = createProgram(gl, vsSource, fsSource);
  gl.useProgram(program);

  const positionLoc   = gl.getAttribLocation(program, "aPosition");
  const uResLoc       = gl.getUniformLocation(program, "uResolution");
  const uTimeLoc      = gl.getUniformLocation(program, "uTime");
  const uDampLoc      = gl.getUniformLocation(program, "uDamping");
  const uCoupleLoc    = gl.getUniformLocation(program, "uCoupling");
  const uNoiseLoc     = gl.getUniformLocation(program, "uNoise");
  const uRhyLoc       = gl.getUniformLocation(program, "uRhythm");
  const uGradLoc      = gl.getUniformLocation(program, "uGradient");
  const uAttrLoc      = gl.getUniformLocation(program, "uAttractor");
  const uCohLoc       = gl.getUniformLocation(program, "uCoherence");

  const quad = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, quad);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -1,-1, 1,-1, -1,1,
    -1,1, 1,-1, 1,1
  ]), gl.STATIC_DRAW);

  gl.enableVertexAttribArray(positionLoc);
  gl.vertexAttribPointer(positionLoc,2,gl.FLOAT,false,0,0);

  const sliders = {
    damping: document.getElementById("damping"),
    coupling: document.getElementById("coupling"),
    noise: document.getElementById("noise"),
    rhythm: document.getElementById("rhythm"),
    gradient: document.getElementById("gradient"),
    attractor: document.getElementById("attractor"),
    coherence: document.getElementById("coherence")
  };

  const evf = {
    damping: 0.4,
    coupling: 0.7,
    noise:    0.5,
    rhythm:   0.6,
    gradient: 0.6,
    attractor:0.7,
    coherence:0.5
  };

  function lerp(a,b,t){ return a + (b-a)*t; }

  // ------------------ PARTICLES (small, grayscale, many) ------------------
  const pCanvas = document.getElementById("particles");
  const pCtx = pCanvas.getContext("2d");
  let particles = [];

  function resizeParticles() {
    const rect = pCanvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    pCanvas.width = rect.width * dpr;
    pCanvas.height = rect.height * dpr;
    pCtx.setTransform(dpr,0,0,dpr,0,0);
  }

  function initParticles() {
    const w = window.innerWidth;
    const h = window.innerHeight;
    particles = [];

    const count = Math.floor(w * 2.4); // ~1500–3000

    for (let i = 0; i < count; i++) {
      particles.push({
        x: Math.random()*w,
        y: Math.random()*h,
        vx: 0,
        vy: 0,
        size: 0.6 + Math.random()*0.6,
        life: Math.random()*5,
        maxLife: 5 + Math.random()*5
      });
    }
  }

  function updateParticles() {
    const w = window.innerWidth;
    const h = window.innerHeight;

    const GRAD = 0.001 + evf.gradient * 0.01;
    const ATTR = 0.002 + evf.attractor * 0.018;
    const NOISE = evf.noise * 0.002;
    const COUP = evf.coupling * 0.003;
    const DAMP = 0.9 + evf.damping * 0.05;

    particles.forEach(p => {
      p.vx += GRAD * 0.5;
      p.vy += GRAD * -0.7;

      const ax = w * 0.72, ay = h * 0.65;
      const dx = ax - p.x, dy = ay - p.y;
      const dist = Math.sqrt(dx*dx + dy*dy) + 0.001;

      p.vx += (dx/dist) * ATTR;
      p.vy += (dy/dist) * ATTR;

      p.vx += (Math.random() - 0.5) * NOISE;
      p.vy += (Math.random() - 0.5) * NOISE;

      p.vx += (0.2 - p.vx) * COUP;
      p.vy += (-0.05 - p.vy) * COUP;

      p.vx *= DAMP;
      p.vy *= DAMP;

      p.x += p.vx;
      p.y += p.vy;

      if (p.x < 0) p.x += w;
      if (p.x > w) p.x -= w;
      if (p.y < 0) p.y += h;
      if (p.y > h) p.y -= h;

      p.life += 0.02;
      if (p.life > p.maxLife) {
        p.x = Math.random()*w; p.y = Math.random()*h;
        p.vx=0; p.vy=0; p.life=0;
      }
    });
  }

  function drawParticles() {
    const rect = pCanvas.getBoundingClientRect();
    pCtx.clearRect(0,0,rect.width,rect.height);

    particles.forEach(p => {
      const alpha = 0.15 + 0.4*(1 - p.life/p.maxLife);
      const grey = 0.1 + Math.random()*0.2;
      const c = Math.round(grey*255);
      pCtx.fillStyle = `rgba(${c},${c},${c},${alpha})`;

      pCtx.beginPath();
      pCtx.arc(p.x, p.y, p.size, 0, Math.PI*2);
      pCtx.fill();
    });
  }

  // ------------------ MAIN LOOP ------------------
  const t0 = performance.now();
  function render() {
    resizeGL();
    const t = (performance.now() - t0) / 1000;

    const speed = 0.08;
    evf.damping   = lerp(evf.damping,   parseFloat(sliders.damping.value),   speed);
    evf.coupling  = lerp(evf.coupling,  parseFloat(sliders.coupling.value),  speed);
    evf.noise     = lerp(evf.noise,     parseFloat(sliders.noise.value),     speed);
    evf.rhythm    = lerp(evf.rhythm,    parseFloat(sliders.rhythm.value),    speed);
    evf.gradient  = lerp(evf.gradient,  parseFloat(sliders.gradient.value),  speed);
    evf.attractor = lerp(evf.attractor, parseFloat(sliders.attractor.value), speed);
    evf.coherence = lerp(evf.coherence, parseFloat(sliders.coherence.value), speed);

    gl.useProgram(program);
    gl.uniform2f(uResLoc, gl.drawingBufferWidth, gl.drawingBufferHeight);
    gl.uniform1f(uTimeLoc, t);

    gl.uniform1f(uDampLoc, evf.damping);
    gl.uniform1f(uCoupleLoc, evf.coupling);
    gl.uniform1f(uNoiseLoc, evf.noise);
    gl.uniform1f(uRhyLoc, evf.rhythm);
    gl.uniform1f(uGradLoc, evf.gradient);
    gl.uniform1f(uAttrLoc, evf.attractor);
    gl.uniform1f(uCohLoc, evf.coherence);

    gl.drawArrays(gl.TRIANGLES, 0, 6);

    updateParticles();
    drawParticles();

    requestAnimationFrame(render);
  }

  resizeGL();
  resizeParticles();
  initParticles();
  render();
</script>
</body>
</html>

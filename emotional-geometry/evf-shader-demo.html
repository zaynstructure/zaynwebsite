<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>EVF Shader Demo · Inverted + Particles</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: #020617;
      color: #e5e7eb;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    
    #controls {
  background: #000;
  padding: 16px;
  border-top: 1px solid #222;

  display: flex;
  flex-wrap: wrap;
  gap: 10px 18px;
  align-items: center;

  font-size: 12px;
  color: #d4d4d4;
}
  color: #d4d4d4;
}
    .artist-summary {
  flex-basis: 100%;
  margin-bottom: 6px;
  color: #9ca3af;
  font-size: 12px;
  line-height: 1.35;
}
    
    .label {
  display: flex;
  align-items: center;
  gap: 6px;
}

.label .name {
  width: 74px;
  text-transform: lowercase;
  color: #9ca3af;
}

.label input[type="range"] {
  width: 130px;
}
    #glWrap {
      flex: 1;
      position: relative;
    }
    #glCanvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    #particles {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      display: block;
    }
  </style>
</head>
<body>
  <div id="glWrap">
  <canvas id="glCanvas"></canvas>
  <canvas id="particles"></canvas>
</div>
<div id="controls">
  
  <label class="label">
    <span class="name">damping</span>
    <input id="damping" type="range" min="0" max="1" step="0.01" value="0.4">
  </label>

  <label class="label">
    <span class="name">coupling</span>
    <input id="coupling" type="range" min="0" max="1" step="0.01" value="0.7">
  </label>

  <label class="label">
    <span class="name">noise</span>
    <input id="noise" type="range" min="0" max="1" step="0.01" value="0.5">
  </label>

  <label class="label">
    <span class="name">rhythm</span>
    <input id="rhythm" type="range" min="0" max="1" step="0.01" value="0.6">
  </label>

  <label class="label">
    <span class="name">gradient</span>
    <input id="gradient" type="range" min="0" max="1" step="0.01" value="0.6">
  </label>

  <label class="label">
    <span class="name">attractor</span>
    <input id="attractor" type="range" min="0" max="1" step="0.01" value="0.7">
  </label>

  <label class="label">
    <span class="name">coherence</span>
    <input id="coherence" type="range" min="0" max="1" step="0.01" value="0.5">
  </label>

</div>
 <div class="artist-summary">
  This view models emotion as a multi-parameter system. 
  Damping is the rate at which an emotional signal returns to baseline. 
  Coupling is the degree to which external emotional inputs alter your state. 
  Noise is background mental interference during emotion. 
  Rhythm is the stability of your emotional cycles across the day. 
  Gradient is the directional drive produced by motivation or intent. 
  Attractor is the dominance of a single emotional theme. 
  Coherence is how well emotional signals align into a unified state.
</div>
  
<script>
  // ------------------ WEBGL SETUP ------------------
  const canvas = document.getElementById('glCanvas');
  const gl = canvas.getContext('webgl');
  if (!gl) { alert('WebGL not supported'); }

  function resizeGL() {
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    const w = rect.width * dpr, h = rect.height * dpr;
    if (canvas.width !== w || canvas.height !== h) {
      canvas.width = w; canvas.height = h;
      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
    }
  }
  window.addEventListener('resize', () => resizeGL());

  const vsSource = `attribute vec2 aPosition;
    void main() { gl_Position = vec4(aPosition, 0.0, 1.0); }`;

  // ------------------ EVF SHADER (inverted colors) ------------------
  const fsSource = `
precision highp float;

uniform float uDamping, uCoupling, uNoise, uRhythm;
uniform float uGradient, uAttractor, uCoherence;
uniform vec2  uResolution;
uniform float uTime;

float hash(vec2 p){
    return fract(sin(dot(p, vec2(127.1,311.7))) * 43758.5453);
}

float noise(vec2 p){
    vec2 i = floor(p);
    vec2 f = fract(p);
    float a = hash(i);
    float b = hash(i + vec2(1.0,0.0));
    float c = hash(i + vec2(0.0,1.0));
    float d = hash(i + vec2(1.0,1.0));
    vec2 u = f*f*(3.0-2.0*f);
    return mix(mix(a,b,u.x), mix(c,d,u.x), u.y);
}

// Voronoi-ish edge distance for polygonal clustering
float voronoiEdge(vec2 p, float scale){
    vec2 g = floor(p * scale);
    float d = 1.0;
    for (int y=-1; y<=1; y++) {
        for (int x=-1; x<=1; x++) {
            vec2 o = vec2(x,y);
            vec2 r = g + o + noise(g + o);
            vec2 diff = r/scale - p;
            d = min(d, length(diff));
        }
    }
    return d;
}

float soft(float x){ return x / (1.0 + abs(x)); }

// core EVF height field:
// h      = height
// attr   = attractor strength
// nGrad  = noise-gradient magnitude
void computeField(vec2 p, out float h, out float attr, out float nGrad){
    // coherence: mirror blend
    vec2 q  = p;
    vec2 q2 = vec2(-q.x, q.y);
    q = mix(q, q2, uCoherence * 0.5);

    // GRADIENT (∇φ): directional slope
    vec2 gdir = normalize(vec2(0.7,-0.4));
    float grad = dot(q,gdir) * (1.0 + 2.0 * uGradient);

    // ATTRACTOR: crater-like pull
    vec2 aPos = vec2(0.5,-0.5);
    float dA = length(q - aPos);
    float attractField = exp(-dA * (1.5 + 4.0 * (1.0 - uAttractor)));

    // polygonal clusters (coupling)
    float cellScale = mix(10.0, 5.0, uCoupling);
    float edges = voronoiEdge(q, cellScale);
    float facets = smoothstep(0.0, 0.55, edges);

    // NOISE (ξ) with gradient
    float noiseScale = mix(3.0, 18.0, uNoise);
    float n0 = noise(q * noiseScale + uTime * 0.2);
    float turb = pow(n0, mix(2.0, 0.4, uNoise));

    float eps = 0.03;
    float nX = noise(q * noiseScale + vec2(eps,0.0));
    float nY = noise(q * noiseScale + vec2(0.0,eps));
    float noiseGrad = length(vec2(nX - n0, nY - n0));

    // RHYTHM (R): time-based stratified bands
    float stripesFreq = mix(0.0, 18.0, uRhythm);
    float stripes = 0.0;
    if (stripesFreq > 0.0) {
        stripes = sin(q.y * stripesFreq + uTime * 0.6);
        stripes = 0.5 + 0.5 * stripes;
    }

    // scalar field
    float field =
          1.0 * grad
        + 1.7 * attractField
        + 1.2 * (1.0 - facets) * uCoupling
        + 1.2 * turb
        + 0.9 * stripes
        + 1.2 * noiseGrad * uNoise; // noise-gradient shading input

    float contrast = mix(2.0, 0.7, uDamping);
    h     = soft(field * contrast);
    attr  = attractField;
    nGrad = noiseGrad;
}

void main(){
    vec2 uv = (gl_FragCoord.xy / uResolution.xy) * 2.0 - 1.0;
    uv.x *= uResolution.x / uResolution.y;

    // zoom out a bit
    vec2 p = uv * 1.7;

    // base height, attractor, noise-gradient
    float h, attr, nGrad;
    computeField(p, h, attr, nGrad);

    // height-map lighting: estimate normals from height differences
    float eps = 0.04;
    float hX, tmpA, tmpN;
    computeField(p + vec2(eps, 0.0), hX, tmpA, tmpN);
    float hY;
    computeField(p + vec2(0.0, eps), hY, tmpA, tmpN);

    vec3 normal = normalize(vec3(hX - h, hY - h, 0.09));
    vec3 lightDir = normalize(vec3(0.4, 0.7, 0.8));
    float diff = clamp(dot(normal, lightDir), 0.0, 1.0);

    // Friendly Geometry style palette
    vec3 deep  = vec3(0.08, 0.12, 0.19);
    vec3 beige = vec3(0.90, 0.83, 0.75);
    vec3 teal  = vec3(0.48, 0.77, 0.88);

    // height → base color
    vec3 col = mix(deep, beige, 0.5 + 0.5 * h);

    // attractor glow: tint toward teal near attractor
    col = mix(col, teal, attr * 0.9);

    // noise-gradient shading: darken where noise changes quickly (crackle)
    col -= nGrad * uNoise * 0.3;

    // apply height-map lighting
    float lightFactor = 0.35 + 0.65 * diff;
    col *= lightFactor;

    // small grain
    float g = noise(gl_FragCoord.xy * 0.8);
    col *= 0.96 + 0.04 * (g - 0.5);

    // gentle vignette
    float vig = smoothstep(1.4, 0.65, length(uv));
    col *= vig;

    // keep the inverted look you liked
    col = 1.0 - col;

    gl_FragColor = vec4(col, 1.0);
}
`;
  function compileShader(gl, type, src) {
    const s = gl.createShader(type);
    gl.shaderSource(s, src); gl.compileShader(s);
    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
      console.error(gl.getShaderInfoLog(s)); return null;
    }
    return s;
  }

  function createProgram(gl, vs, fs) {
    const p = gl.createProgram();
    gl.attachShader(p, compileShader(gl, gl.VERTEX_SHADER, vs));
    gl.attachShader(p, compileShader(gl, gl.FRAGMENT_SHADER, fs));
    gl.linkProgram(p);
    if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
      console.error(gl.getProgramInfoLog(p)); return null;
    }
    return p;
  }

  const program = createProgram(gl, vsSource, fsSource);
  gl.useProgram(program);

  const positionLoc   = gl.getAttribLocation(program, "aPosition");
  const uResLoc       = gl.getUniformLocation(program, "uResolution");
  const uTimeLoc      = gl.getUniformLocation(program, "uTime");
  const uDampLoc      = gl.getUniformLocation(program, "uDamping");
  const uCoupleLoc    = gl.getUniformLocation(program, "uCoupling");
  const uNoiseLoc     = gl.getUniformLocation(program, "uNoise");
  const uRhyLoc       = gl.getUniformLocation(program, "uRhythm");
  const uGradLoc      = gl.getUniformLocation(program, "uGradient");
  const uAttrLoc      = gl.getUniformLocation(program, "uAttractor");
  const uCohLoc       = gl.getUniformLocation(program, "uCoherence");

  const quad = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, quad);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -1,-1, 1,-1, -1,1,
    -1,1, 1,-1, 1,1
  ]), gl.STATIC_DRAW);

  gl.enableVertexAttribArray(positionLoc);
  gl.vertexAttribPointer(positionLoc,2,gl.FLOAT,false,0,0);

  const sliders = {
    damping: document.getElementById("damping"),
    coupling: document.getElementById("coupling"),
    noise: document.getElementById("noise"),
    rhythm: document.getElementById("rhythm"),
    gradient: document.getElementById("gradient"),
    attractor: document.getElementById("attractor"),
    coherence: document.getElementById("coherence")
  };

  const evf = {
    damping: 0.4,
    coupling: 0.7,
    noise:    0.5,
    rhythm:   0.6,
    gradient: 0.6,
    attractor:0.7,
    coherence:0.5
  };

  function lerp(a,b,t){ return a + (b-a)*t; }

  // ------------------ PARTICLES (small, grayscale, many) ------------------
  const pCanvas = document.getElementById("particles");
  const pCtx = pCanvas.getContext("2d");
  let particles = [];

  function resizeParticles() {
    const rect = pCanvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    pCanvas.width = rect.width * dpr;
    pCanvas.height = rect.height * dpr;
    pCtx.setTransform(dpr,0,0,dpr,0,0);
  }

  function initParticles() {
    const w = window.innerWidth;
    const h = window.innerHeight;
    particles = [];

    const count = Math.floor(w * 2.4); // ~1500–3000

    for (let i = 0; i < count; i++) {
      particles.push({
        x: Math.random()*w,
        y: Math.random()*h,
        vx: 0,
        vy: 0,
        size: 0.6 + Math.random()*0.6,
        life: Math.random()*5,
        maxLife: 5 + Math.random()*5
      });
    }
  }

  function updateParticles() {
    const w = window.innerWidth;
    const h = window.innerHeight;

    const GRAD = 0.001 + evf.gradient * 0.01;
    const ATTR = 0.002 + evf.attractor * 0.018;
    const NOISE = evf.noise * 0.002;
    const COUP = evf.coupling * 0.003;
    const DAMP = 0.9 + evf.damping * 0.05;

    particles.forEach(p => {
      p.vx += GRAD * 0.5;
      p.vy += GRAD * -0.7;

      const ax = w * 0.72, ay = h * 0.65;
      const dx = ax - p.x, dy = ay - p.y;
      const dist = Math.sqrt(dx*dx + dy*dy) + 0.001;

      p.vx += (dx/dist) * ATTR;
      p.vy += (dy/dist) * ATTR;

      p.vx += (Math.random() - 0.5) * NOISE;
      p.vy += (Math.random() - 0.5) * NOISE;

      p.vx += (0.2 - p.vx) * COUP;
      p.vy += (-0.05 - p.vy) * COUP;

      p.vx *= DAMP;
      p.vy *= DAMP;

      p.x += p.vx;
      p.y += p.vy;

      if (p.x < 0) p.x += w;
      if (p.x > w) p.x -= w;
      if (p.y < 0) p.y += h;
      if (p.y > h) p.y -= h;

      p.life += 0.02;
      if (p.life > p.maxLife) {
        p.x = Math.random()*w; p.y = Math.random()*h;
        p.vx=0; p.vy=0; p.life=0;
      }
    });
  }

  function drawParticles() {
    const rect = pCanvas.getBoundingClientRect();
    pCtx.clearRect(0,0,rect.width,rect.height);

    particles.forEach(p => {
      const alpha = 0.15 + 0.4*(1 - p.life/p.maxLife);
      const grey = 0.1 + Math.random()*0.2;
      const c = Math.round(grey*255);
      pCtx.fillStyle = `rgba(${c},${c},${c},${alpha})`;

      pCtx.beginPath();
      pCtx.arc(p.x, p.y, p.size, 0, Math.PI*2);
      pCtx.fill();
    });
  }

  // ------------------ MAIN LOOP ------------------
  const t0 = performance.now();
  function render() {
    resizeGL();
    const t = (performance.now() - t0) / 1000;

    const speed = 0.08;
    evf.damping   = lerp(evf.damping,   parseFloat(sliders.damping.value),   speed);
    evf.coupling  = lerp(evf.coupling,  parseFloat(sliders.coupling.value),  speed);
    evf.noise     = lerp(evf.noise,     parseFloat(sliders.noise.value),     speed);
    evf.rhythm    = lerp(evf.rhythm,    parseFloat(sliders.rhythm.value),    speed);
    evf.gradient  = lerp(evf.gradient,  parseFloat(sliders.gradient.value),  speed);
    evf.attractor = lerp(evf.attractor, parseFloat(sliders.attractor.value), speed);
    evf.coherence = lerp(evf.coherence, parseFloat(sliders.coherence.value), speed);

    gl.useProgram(program);
    gl.uniform2f(uResLoc, gl.drawingBufferWidth, gl.drawingBufferHeight);
    gl.uniform1f(uTimeLoc, t);

    gl.uniform1f(uDampLoc, evf.damping);
    gl.uniform1f(uCoupleLoc, evf.coupling);
    gl.uniform1f(uNoiseLoc, evf.noise);
    gl.uniform1f(uRhyLoc, evf.rhythm);
    gl.uniform1f(uGradLoc, evf.gradient);
    gl.uniform1f(uAttrLoc, evf.attractor);
    gl.uniform1f(uCohLoc, evf.coherence);

    gl.drawArrays(gl.TRIANGLES, 0, 6);

    updateParticles();
    drawParticles();

    requestAnimationFrame(render);
  }

  resizeGL();
  resizeParticles();
  initParticles();
  render();
</script>
</body>
</html>

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>EVF Shader Demo · Morphing Field + Particles</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: #020617;
      color: #e5e7eb;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    #controls {
      padding: 8px 10px;
      font-size: 11px;
      background: #020617;
      border-bottom: 1px solid #111827;
      display: flex;
      flex-wrap: wrap;
      gap: 6px 12px;
      align-items: center;
    }
    .label {
      display: flex;
      align-items: center;
      gap: 4px;
      color: #9ca3af;
    }
    .label span.name {
      width: 70px;
      text-transform: lowercase;
    }
    .label input[type="range"] {
      width: 120px;
    }
    #glWrap {
      flex: 1;
      position: relative;
    }
    #glCanvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    #particles {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      display: block;
    }
  </style>
</head>
<body>
<div id="controls">
  <span style="font-weight:600;margin-right:8px;">EVF field demo</span>
  <label class="label">
    <span class="name">damping</span>
    <input id="damping" type="range" min="0" max="1" step="0.01" value="0.4">
  </label>
  <label class="label">
    <span class="name">coupling</span>
    <input id="coupling" type="range" min="0" max="1" step="0.01" value="0.7">
  </label>
  <label class="label">
    <span class="name">noise</span>
    <input id="noise" type="range" min="0" max="1" step="0.01" value="0.5">
  </label>
  <label class="label">
    <span class="name">rhythm</span>
    <input id="rhythm" type="range" min="0" max="1" step="0.01" value="0.6">
  </label>
  <label class="label">
    <span class="name">gradient</span>
    <input id="gradient" type="range" min="0" max="1" step="0.01" value="0.6">
  </label>
  <label class="label">
    <span class="name">attractor</span>
    <input id="attractor" type="range" min="0" max="1" step="0.01" value="0.7">
  </label>
  <label class="label">
    <span class="name">coherence</span>
    <input id="coherence" type="range" min="0" max="1" step="0.01" value="0.5">
  </label>
</div>

<div id="glWrap">
  <canvas id="glCanvas"></canvas>
  <canvas id="particles"></canvas>
</div>

<script>
  // ------------------ WEBGL SETUP ------------------
  const canvas = document.getElementById('glCanvas');
  const gl = canvas.getContext('webgl');
  if (!gl) {
    alert('WebGL not supported');
  }

  function resizeGL() {
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    const w = rect.width * dpr;
    const h = rect.height * dpr;
    if (canvas.width !== w || canvas.height !== h) {
      canvas.width = w;
      canvas.height = h;
      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
    }
  }
  window.addEventListener('resize', () => {
    resizeGL();
    resizeParticles();
  });

  const vsSource = `
    attribute vec2 aPosition;
    void main() {
      gl_Position = vec4(aPosition, 0.0, 1.0);
    }
  `;

  // --- polygonal landscape EVF shader ---
  const fsSource = `
precision highp float;

uniform float uDamping;
uniform float uCoupling;
uniform float uNoise;
uniform float uRhythm;
uniform float uGradient;
uniform float uAttractor;
uniform float uCoherence;

uniform vec2  uResolution;
uniform float uTime;

float hash(vec2 p) {
    return fract(sin(dot(p, vec2(127.1,311.7))) * 43758.5453);
}

float noise(vec2 p){
    vec2 i = floor(p);
    vec2 f = fract(p);
    float a = hash(i);
    float b = hash(i+vec2(1.0,0.0));
    float c = hash(i+vec2(0.0,1.0));
    float d = hash(i+vec2(1.0,1.0));
    vec2 u = f*f*(3.0-2.0*f);
    return mix(mix(a,b,u.x), mix(c,d,u.x), u.y);
}

// distance to nearest cell boundary (polygonal effect)
float voronoiEdge(vec2 p, float scale){
    vec2 g = floor(p*scale);
    float d = 1.0;
    for(int y=-1;y<=1;y++){
        for(int x=-1;x<=1;x++){
            vec2 o = vec2(x,y);
            vec2 r = g + o + noise(g+o);
            vec2 diff = r/scale - p;
            d = min(d, length(diff));
        }
    }
    return d;
}

// soft "tanh"
float soft(float x){ return x / (1.0 + abs(x)); }

// core EVF height field, returns:
// h = height (0..1-ish), attr = attractor strength,
// ng = noise-gradient magnitude
void computeField(vec2 p, out float h, out float attr, out float ng){
    // coherence: blend with mirrored variant
    vec2 q = p;
    vec2 q2 = vec2(-q.x, q.y);
    q = mix(q, q2, uCoherence*0.5);

    // GRADIENT (∇φ): slope
    vec2 gdir = normalize(vec2(0.7,-0.4));
    float grad = dot(q,gdir) * (1.0 + 2.0*uGradient);

    // ATTRACTOR: crater-like structure
    vec2 aPos = vec2(0.5,-0.5);
    float dA = length(q - aPos);
    float attractField = exp(-dA * (2.0 + 6.0*(1.0-uAttractor)));
    attractField *= mix(0.7,1.8,uAttractor);

    // POLYGONAL CLUSTERS (coupling)
    float cellScale = mix(12.0, 4.0, uCoupling);
    float edges = voronoiEdge(q, cellScale);
    float facets = smoothstep(0.0, 0.55, edges);

    // NOISE (ξ)
    float noiseScale = mix(3.0,18.0,uNoise);
    float n0 = noise(q*noiseScale + uTime*0.2);
    float turbulence = pow(n0, mix(2.0,0.4,uNoise));

    // noise *gradient* (how fast noise changes in x/y)
    float eps = 0.03;
    float nX = noise(q*noiseScale + vec2(eps,0.0));
    float nY = noise(q*noiseScale + vec2(0.0,eps));
    float noiseGrad = length(vec2(nX - n0, nY - n0)); // 0..~something

    // RHYTHM (R): stratification layers
    float stripesFreq = mix(0.0,18.0,uRhythm);
    float stripes = 0.0;
    if (stripesFreq > 0.0) {
        stripes = sin(q.y * stripesFreq + uTime*0.6);
        stripes = 0.5 + 0.5*stripes;
    }

    // LANDSCAPE HEIGHT FIELD (scalar)
    float field =
          1.0 * grad +
          2.0 * attractField +
          1.2 * (1.0 - facets) * uCoupling +
          1.4 * turbulence +
          0.9 * stripes +
          1.2 * noiseGrad * uNoise; // noise-gradient contribution

    // DAMPING: soften/harden contrast
    float contrast = mix(2.0, 0.6, uDamping);
    h = soft(field * contrast);
    attr = attractField;
    ng = noiseGrad;
}

void main(){
    vec2 uv = (gl_FragCoord.xy/uResolution.xy)*2.0-1.0;
    uv.x *= uResolution.x/uResolution.y;

    // zoom slightly out
    vec2 p = uv * 1.7;

    // base height / attractor / noise gradient
    float h, attr, ng;
    computeField(p, h, attr, ng);

    // estimate height gradient for fake normals (height-map shading)
    float eps = 0.04;
    float hX, dummy1, dummy2;
    computeField(p + vec2(eps,0.0), hX, dummy1, dummy2);
    float hY;
    computeField(p + vec2(0.0,eps), hY, dummy1, dummy2);

    // tangent-space normal (x = dh/dx, y = dh/dy, z = "up")
    vec3 n = normalize(vec3(hX - h, hY - h, 0.09));

    // light direction
    vec3 lightDir = normalize(vec3(0.4, 0.7, 0.8));
    float diff = clamp(dot(n, lightDir), 0.0, 1.0);

    // Friendly Geometry palette
    vec3 deep  = vec3(0.08,0.12,0.19);
    vec3 beige = vec3(0.90,0.83,0.75);
    vec3 teal  = vec3(0.48,0.77,0.88);

    // height → base color
    vec3 col = mix(deep, beige, 0.5 + 0.5*h);

    // attractor glow tint
    col = mix(col, teal, attr * 0.8);

    // noise gradient darkening (edges / crackle)
    col -= ng * uNoise * 0.3;

    // apply lighting from height-map normal
    float lightFactor = 0.35 + 0.65 * diff;
    col *= lightFactor;

    // grain
    float g = noise(gl_FragCoord.xy*0.8);
    col *= 0.96 + 0.04*(g-0.5);

    // vignette
    float vig = smoothstep(1.4,0.65,length(uv));
    col *= vig;
col = 1.0 - col;
    gl_FragColor = vec4(col,1.0);
}
`;

  function compileShader(gl, type, source) {
    const s = gl.createShader(type);
    gl.shaderSource(s, source);
    gl.compileShader(s);
    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
      console.error(gl.getShaderInfoLog(s));
      gl.deleteShader(s);
      return null;
    }
    return s;
  }

  function createProgram(gl, vsSource, fsSource) {
    const vs = compileShader(gl, gl.VERTEX_SHADER, vsSource);
    const fs = compileShader(gl, gl.FRAGMENT_SHADER, fsSource);
    const prog = gl.createProgram();
    gl.attachShader(prog, vs);
    gl.attachShader(prog, fs);
    gl.linkProgram(prog);
    if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
      console.error(gl.getProgramInfoLog(prog));
      gl.deleteProgram(prog);
      return null;
    }
    return prog;
  }

  const program = createProgram(gl, vsSource, fsSource);
  gl.useProgram(program);

  const positionLoc   = gl.getAttribLocation(program, 'aPosition');
  const uDampingLoc   = gl.getUniformLocation(program, 'uDamping');
  const uCouplingLoc  = gl.getUniformLocation(program, 'uCoupling');
  const uNoiseLoc     = gl.getUniformLocation(program, 'uNoise');
  const uRhythmLoc    = gl.getUniformLocation(program, 'uRhythm');
  const uGradientLoc  = gl.getUniformLocation(program, 'uGradient');
  const uAttractorLoc = gl.getUniformLocation(program, 'uAttractor');
  const uCoherenceLoc = gl.getUniformLocation(program, 'uCoherence');
  const uResolutionLoc= gl.getUniformLocation(program, 'uResolution');
  const uTimeLoc      = gl.getUniformLocation(program, 'uTime');

  // fullscreen quad
  const quadBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
  const quadVerts = new Float32Array([
    -1, -1,
     1, -1,
    -1,  1,
    -1,  1,
     1, -1,
     1,  1
  ]);
  gl.bufferData(gl.ARRAY_BUFFER, quadVerts, gl.STATIC_DRAW);

  gl.enableVertexAttribArray(positionLoc);
  gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

  const sliders = {
    damping:   document.getElementById('damping'),
    coupling:  document.getElementById('coupling'),
    noise:     document.getElementById('noise'),
    rhythm:    document.getElementById('rhythm'),
    gradient:  document.getElementById('gradient'),
    attractor: document.getElementById('attractor'),
    coherence: document.getElementById('coherence')
  };

  // ------------------ EVF STATE (MORPHING) ------------------
  const evf = {
    damping:   parseFloat(sliders.damping.value),
    coupling:  parseFloat(sliders.coupling.value),
    noise:     parseFloat(sliders.noise.value),
    rhythm:    parseFloat(sliders.rhythm.value),
    gradient:  parseFloat(sliders.gradient.value),
    attractor: parseFloat(sliders.attractor.value),
    coherence: parseFloat(sliders.coherence.value)
  };

  function lerp(a,b,t){ return a + (b-a)*t; }

  // ------------------ PARTICLES (swarm, small, grayscale) ------------------
const pCanvas = document.getElementById('particles');
const pCtx = pCanvas.getContext('2d');
let particles = [];

function resizeParticles() {
  const rect = pCanvas.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  pCanvas.width = rect.width * dpr;
  pCanvas.height = rect.height * dpr;
  pCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
}

function initParticles() {
  particles = [];

  // many more, but very small (dust scale)
  const count = Math.floor(window.innerWidth * 2.5); // ~1500–3000 on desktop

  for (let i = 0; i < count; i++) {
    particles.push({
      x: Math.random() * window.innerWidth,
      y: Math.random() * window.innerHeight,
      vx: 0,
      vy: 0,
      size: 0.6 + Math.random() * 0.6,  // VERY SMALL
      life: Math.random() * 3,
      maxLife: 3 + Math.random() * 3
    });
  }
}

function updateParticles(t) {
  const GRAD = 0.001 + evf.gradient * 0.01;
  const ATTR = 0.002 + evf.attractor * 0.018;
  const NOISE = evf.noise * 0.0025;
  const COUP  = evf.coupling * 0.003;
  const DAMP  = 0.9 + evf.damping * 0.05;

  const w = window.innerWidth;
  const h = window.innerHeight;

  particles.forEach(p => {
    // gradient drift
    p.vx += GRAD * 0.4;
    p.vy += GRAD * -0.6;

    // attractor pull (soft)
    const ax = w * 0.72;
    const ay = h * 0.65;
    const dx = ax - p.x;
    const dy = ay - p.y;
    const dist = Math.sqrt(dx*dx + dy*dy) + 0.001;
    p.vx += (dx/dist) * ATTR;
    p.vy += (dy/dist) * ATTR;

    // local coupling (flocking-like compression)
    p.vx += (Math.random() - 0.5) * COUP;
    p.vy += (Math.random() - 0.5) * COUP;

    // turbulence
    p.vx += (Math.random() - 0.5) * NOISE;
    p.vy += (Math.random() - 0.5) * NOISE;

    // damping
    p.vx *= DAMP;
    p.vy *= DAMP;

    // move
    p.x += p.vx;
    p.y += p.vy;

    // wrap edges
    if (p.x < 0) p.x += w;
    if (p.y < 0) p.y += h;
    if (p.x > w) p.x -= w;
    if (p.y > h) p.y -= h;

    // life fade
    p.life += 0.02;
    if (p.life > p.maxLife) {
      p.x = Math.random() * w;
      p.y = Math.random() * h;
      p.vx = p.vy = 0;
      p.life = 0;
    }
  });
}

function drawParticles() {
  pCtx.clearRect(0, 0, pCanvas.width, pCanvas.height);

  particles.forEach(p => {
    const alpha = 0.25 + 0.45 * (1 - p.life / p.maxLife);

    // grayscale  → black to mid-grey (very subtle, FG-like)
    const grey = 0.1 + Math.random() * 0.2;
    pCtx.fillStyle = `rgba(${grey*255}, ${grey*255}, ${grey*255}, ${alpha})`;

    pCtx.beginPath();
    pCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    pCtx.fill();
  });
}

function loopParticles() {
  updateParticles();
  drawParticles();
  requestAnimationFrame(loopParticles);
}

resizeParticles();
initParticles();
loopParticles();
window.addEventListener('resize', () => {
  resizeParticles();
  initParticles();
});

  // ------------------ MAIN LOOP ------------------
  const start = performance.now();

  function render() {
    resizeGL();

    const t = (performance.now() - start) / 1000;

    // morph EVF toward slider values
    const morphSpeed = 0.08;
    evf.damping   = lerp(evf.damping,   parseFloat(sliders.damping.value),   morphSpeed);
    evf.coupling  = lerp(evf.coupling,  parseFloat(sliders.coupling.value),  morphSpeed);
    evf.noise     = lerp(evf.noise,     parseFloat(sliders.noise.value),     morphSpeed);
    evf.rhythm    = lerp(evf.rhythm,    parseFloat(sliders.rhythm.value),    morphSpeed);
    evf.gradient  = lerp(evf.gradient,  parseFloat(sliders.gradient.value),  morphSpeed);
    evf.attractor = lerp(evf.attractor, parseFloat(sliders.attractor.value), morphSpeed);
    evf.coherence = lerp(evf.coherence, parseFloat(sliders.coherence.value), morphSpeed);

    gl.useProgram(program);
    gl.uniform2f(uResolutionLoc, gl.drawingBufferWidth, gl.drawingBufferHeight);
    gl.uniform1f(uTimeLoc, t);

    gl.uniform1f(uDampingLoc,   evf.damping);
    gl.uniform1f(uCouplingLoc,  evf.coupling);
    gl.uniform1f(uNoiseLoc,     evf.noise);
    gl.uniform1f(uRhythmLoc,    evf.rhythm);
    gl.uniform1f(uGradientLoc,  evf.gradient);
    gl.uniform1f(uAttractorLoc, evf.attractor);
    gl.uniform1f(uCoherenceLoc, evf.coherence);

    gl.drawArrays(gl.TRIANGLES, 0, 6);

    updateParticles(t);
    drawParticles();

    requestAnimationFrame(render);
  }

  resizeGL();
  resizeParticles();
  initParticles();
  render();
</script>
</body>
</html>

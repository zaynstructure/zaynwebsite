<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>EVF Shader Demo · Inverted + Particles</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />

<style>
* { box-sizing: border-box; }

html, body {
  margin: 0;
  padding: 0;
  background: #020617;
  color: #e5e7eb;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
}

body {
  display: flex;
  flex-direction: column;
}

/* visual area */
#glWrap {
  position: relative;
  height: 320px;
}

/* field canvas */
#glCanvas {
  width: 100%;
  height: 100%;
  display: block;
}

/* particle overlay */
#particles {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  display: block;
  z-index: 1;
}

/* controls */
#controls {
  background: #000;
  padding: 8px 10px;
  border-top: 1px solid #222;
  display: flex;
  gap: 12px;
  align-items: flex-start;
  font-size: 11px;
  color: #d4d4d4;
  pointer-events: auto;
  z-index: 9999;
}

/* presets column */
.presets {
  display: flex;
  flex-direction: column;
  gap: 4px;
  min-width: 170px;
}

.presets-title {
  font-size: 10px;
  text-transform: lowercase;
  color: #6b7280;
}

.preset-grid {
  display: grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  gap: 4px;
}

.preset-btn {
  border: 1px solid #374151;
  background: #000;
  color: #d1d5db;
  font-size: 10px;
  padding: 3px 0;
  border-radius: 4px;
  cursor: pointer;
  text-align: center;
}

.preset-btn.active {
  border-color: #38bdf8;
  color: #e5f3ff;
}

.preset-description {
  margin-top: 4px;
  font-size: 10px;
  line-height: 1.3;
  color: #9ca3af;
}

/* sliders */
.controls-main {
  display: flex;
  flex-wrap: wrap;
  gap: 6px 14px;
  align-items: center;
}

.label {
  display: flex;
  align-items: center;
  gap: 4px;
}

.label .name {
  width: 68px;
  text-transform: lowercase;
  color: #9ca3af;
  font-size: 10px;
}

.label input[type="range"] {
  width: 110px;
}

.label select {
  font-size: 10px;
  padding: 1px 4px;
  background: #020617;
  color: #e5e7eb;
  border-radius: 4px;
  border: 1px solid #374151;
}

/* dev panel */
.dev-panel {
  position: relative;
  width: 100%;
  padding: 10px 14px;
  background: #0a0a0a;
  border-top: 1px solid #333;
  color: #ddd;
  font-size: 11px;
}

.dev-panel.hidden { display: none; }

.dev-title {
  font-size: 10px;
  text-transform: lowercase;
  color: #9ca3af;
  margin-bottom: 4px;
}

.dev-row { margin-bottom: 4px; }

.dev-row label {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.dev-row input[type="range"] {
  width: 100%;
}

.dev-val {
  font-size: 9px;
  color: #6b7280;
}

.dev-footer {
  margin-top: 4px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 4px;
}

#devCopyBtn {
  border: 1px solid #374151;
  background: #020617;
  color: #e5e7eb;
  font-size: 9px;
  padding: 2px 6px;
  border-radius: 4px;
  cursor: pointer;
}
#devCopyBtn:hover { border-color: #38bdf8; }

.dev-hint {
  font-size: 8px;
  color: #6b7280;
}
</style>
</head>

<body>

<div id="glWrap">
  <canvas id="glCanvas"></canvas>
  <canvas id="particles"></canvas>
</div>

<!-- CONTROL PANEL -->
<div id="controls">

  <!-- LEFT: PRESETS -->
  <div class="presets">
    <div class="presets-title">presets</div>

    <div class="preset-grid">
      <button class="preset-btn" data-preset="A">A</button>
      <button class="preset-btn" data-preset="B">B</button>
      <button class="preset-btn" data-preset="C">C</button>
      <button class="preset-btn" data-preset="D">D</button>
      <button class="preset-btn" data-preset="E">E</button>
      <button class="preset-btn" data-preset="F">F</button>
    </div>

    <div id="presetDescription" class="preset-description">
      Select a preset to load a field pattern and see a short description.
    </div>
  </div> <!-- ← FIXED closing tag -->

  <!-- RIGHT: SLIDERS -->
  <div class="controls-main">

    <label class="label">
      <span class="name">damping</span>
      <input id="damping" type="range" min="0" max="1" step="0.01" value="0.4">
    </label>

    <label class="label">
      <span class="name">coupling</span>
      <input id="coupling" type="range" min="0" max="1" step="0.01" value="0.7">
    </label>

    <label class="label">
      <span class="name">noise</span>
      <input id="noise" type="range" min="0" max="1" step="0.01" value="0.5">
    </label>

    <label class="label">
      <span class="name">rhythm</span>
      <input id="rhythm" type="range" min="0" max="1" step="0.01" value="0.6">
    </label>

    <label class="label">
      <span class="name">gradient</span>
      <input id="gradient" type="range" min="0" max="1" step="0.01" value="0.6">
    </label>

    <label class="label">
      <span class="name">attractor</span>
      <input id="attractor" type="range" min="0" max="1" step="0.01" value="0.7">
    </label>

    <label class="label">
      <span class="name">coherence</span>
      <span id="coherenceDisplay">—</span>
    </label>

    <label class="label">
      <span class="name">contain</span>
      <select id="containmentMode">
        <option value="porous">porous</option>
        <option value="balanced" selected>balanced</option>
        <option value="tight">tight</option>
      </select>
    </label>

  </div>
</div>

<!-- DEV PANEL (hidden by default) -->
<div id="devPanel" class="dev-panel hidden">
  <div class="dev-title">particles</div>

  <div class="dev-row">
    <label>density
      <input id="pDensity" type="range" min="1" max="12" step="0.5">
      <span id="pDensityVal" class="dev-val"></span>
    </label>
  </div>

  <div class="dev-row">
    <label>size min
      <input id="pSizeMin" type="range" min="0.1" max="3" step="0.05">
      <span id="pSizeMinVal" class="dev-val"></span>
    </label>
  </div>

  <label class="dev-row">
    <span>extra noise</span>
    <input id="dev-noise-extra" type="checkbox">
  </label>

  <div class="dev-row">
    <label>size max
      <input id="pSizeMax" type="range" min="0.2" max="4" step="0.05">
      <span id="pSizeMaxVal" class="dev-val"></span>
    </label>
  </div>

  <div class="dev-footer">
    <button id="devCopyBtn">copy tuning</button>
    <span class="dev-hint">press “p” to toggle panel</span>
  </div>
</div>
 <script>
// ------------------ BASIC SETUP ------------------
const canvas = document.getElementById("glCanvas");
const gl = canvas.getContext("webgl");

if (!gl) alert("WebGL not supported");

function resizeGL() {
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  const w = rect.width * dpr;
  const h = rect.height * dpr;

  if (canvas.width !== w || canvas.height !== h) {
    canvas.width = w;
    canvas.height = h;
    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
  }
}

window.addEventListener("resize", () => {
  resizeGL();
  resizeParticles();
});

// ------------------ SHADER SOURCES ------------------
const vsSource = `
attribute vec2 aPosition;
void main() {
  gl_Position = vec4(aPosition, 0.0, 1.0);
}
`;

const fsSource = `
precision highp float;

uniform float uDamping, uCoupling, uNoise, uRhythm;
uniform float uGradient, uAttractor, uCoherence;
uniform float uNoiseExtra;
uniform float uTime;
uniform vec2  uResolution;
uniform vec2  uAttractorPos;
precision highp float;

uniform float uDamping, uCoupling, uNoise, uRhythm;
uniform float uGradient, uAttractor, uCoherence;
uniform float uNoiseExtra;
uniform vec2  uResolution;
uniform float uTime;
uniform vec2  uAttractorPos;

float hash(vec2 p){
  return fract(sin(dot(p, vec2(127.1,311.7))) * 43758.5453);
}

float noise(vec2 p){
  vec2 i = floor(p);
  vec2 f = fract(p);
  float a = hash(i);
  float b = hash(i + vec2(1.0,0.0));
  float c = hash(i + vec2(0.0,1.0));
  float d = hash(i + vec2(1.0,1.0));
  vec2 u = f*f*(3.0-2.0*f);
  return mix(mix(a,b,u.x), mix(c,d,u.x), u.y);
}

float voronoiEdge(vec2 p, float scale){
  vec2 g = floor(p * scale);
  float d = 1.0;
  for (int y=-1; y<=1; y++) {
    for (int x=-1; x<=1; x++) {
      vec2 o = vec2(x,y);
      vec2 r = g + o + noise(g + o);
      vec2 diff = r/scale - p;
      d = min(d, length(diff));
    }
  }
  return d;
}

float soft(float x){ return x / (1.0 + abs(x)); }

void computeField(vec2 p, vec2 uvScreen, out float h, out float attr, out float nGrad){
  float coh = uCoherence;

  vec2 q  = p;
  vec2 q2 = vec2(-q.x, q.y);
  float mirrorAmt = coh * 0.25;
  q = mix(q, q2, mirrorAmt);

  vec2 gdir = normalize(vec2(0.7, -0.4));
  float grad = dot(q, gdir) * (1.0 + 2.0 * uGradient);
  float GRAD_EPS = 0.03;
  float gradSlider = uGradient;
  float gradGain = GRAD_EPS + (1.0 - GRAD_EPS) * gradSlider;

  float dA = length(uvScreen - uAttractorPos);

  float radius  = mix(1.6, 0.25, uAttractor);
  float falloff = mix(1.0, 6.0, uAttractor);
  float depth   = mix(0.08, 1.4, uAttractor);

  float ring = exp(-pow((dA / radius) - 0.6, 2.0) * (6.0 + 12.0 * uAttractor));

  float attractField =
        exp(-dA * falloff) * depth
      + ring * 0.25 * uAttractor;

  float baseCellScale = mix(10.0, 5.0, uCoupling);
  float cellScale = baseCellScale * mix(1.3, 0.75, coh);
  float edges = voronoiEdge(q, cellScale);
  float facets = smoothstep(0.0, 0.55, edges);

  float noiseScaleBase = mix(3.0, 18.0, uNoise);
  float noiseScale = noiseScaleBase * mix(1.25, 0.75, coh);

  float n0 = noise(q * noiseScale + uTime * 0.2);
  float turb = pow(n0, mix(2.0, 0.4, uNoise));

  float eps = 0.03;
  float nX = noise(q * noiseScale + vec2(eps,0.0));
  float nY = noise(q * noiseScale + vec2(0.0,eps));

  float noiseGrad = length(vec2(nX - n0, nY - n0));

  // ------------------ MICRO-NOISE (ξ_fine) ------------------
  float extraJitter = 0.0;
  if (uNoiseExtra > 0.0) {
      float fineScale = mix(24.0, 52.0, uNoise);
      float fine = noise(q * fineScale + uTime * 0.9);

      float amp = mix(0.3, 1.5, uNoiseExtra);
      extraJitter = (fine - 0.5) * amp * uNoise;

      turb += extraJitter;

      noiseGrad += abs(extraJitter) * 0.9;
  }

  float stripesFreq = mix(0.0, 18.0, uRhythm);
  float stripes = 0.0;
  if (stripesFreq > 0.0) {
    stripes = sin(q.y * stripesFreq + uTime * 0.6);
    stripes = 0.5 + 0.5 * stripes;
    float rhythmAmp = 0.6 + 0.9 * coh;
    stripes = 0.5 + (stripes - 0.5) * rhythmAmp;
  }

  float field =
        1.0 * grad
      + 1.7 * attractField
      + 1.2 * (1.0 - facets) * uCoupling
      + 1.2 * turb
      + 1.6 * stripes
      + 1.2 * noiseGrad * uNoise * mix(1.1, 0.5, coh);

  float contrast = mix(0.9, 1.35, uDamping);
  h     = soft(field * contrast);
  attr  = attractField;
  nGrad = noiseGrad;
}

void main(){
  vec2 uvScreen = gl_FragCoord.xy / uResolution.xy;

  vec2 uv = uvScreen * 2.0 - 1.0;
  uv.x *= uResolution.x / uResolution.y;
  vec2 p = uv * 1.7;

  float h, attr, nGrad;
  computeField(p, uvScreen, h, attr, nGrad);

  float eps = 0.04;
  float hX, tmpA, tmpN;
  computeField(p + vec2(eps, 0.0), uvScreen, hX, tmpA, tmpN);

  float hY;
  computeField(p + vec2(0.0, eps), uvScreen, hY, tmpA, tmpN);

  vec3 normal = normalize(vec3(hX - h, hY - h, 0.09));
  vec3 lightDir = normalize(vec3(0.4, 0.7, 0.8));
  float diff = clamp(dot(normal, lightDir), 0.0, 1.0);

  vec3 deep  = vec3(0.08, 0.12, 0.19);
  vec3 beige = vec3(0.90, 0.83, 0.75);
  vec3 teal  = vec3(0.48, 0.77, 0.88);

  vec3 col = mix(deep, beige, 0.5 + 0.5 * h);
  col = mix(col, teal, attr * 0.9);
  col -= nGrad * uNoise * 0.3;

  float lightFactor = 0.35 + 0.65 * diff;
  col *= lightFactor;

  float g = noise(gl_FragCoord.xy * 0.8);
  col *= 0.96 + 0.04 * (g - 0.5);

  float radius = length(uv);
  float vig = smoothstep(1.4, 0.65, radius);
  col *= vig;

  // inverted look
  col = 1.0 - col;

  // micro-noise tint
  if (uNoiseExtra > 0.0) {
      float microMask = smoothstep(0.08, 0.35, nGrad * uNoise);

      vec3 microTint = vec3(0.80, 0.86, 1.00);
      float tintAmt = 0.20 * uNoiseExtra;
      col = mix(col, microTint, tintAmt * microMask);

      vec3 fadeBase = vec3(0.5);
      float fadeAmt = 0.25 * uNoiseExtra;
      vec3 washed = mix(col, fadeBase, 0.5);

      col = mix(col, washed, fadeAmt * microMask);
  }

  float dampBright = mix(-0.08, 0.10, uDamping);
  col += vec3(dampBright);
  col = clamp(col, 0.0, 1.0);

  float pulse = 0.5 + 0.5 * sin(uTime * 0.7);
  float rAmt  = (uRhythm - 0.5) * 0.14;
  vec3 rTint  = vec3(0.03, -0.02, 0.0) * rAmt * pulse;
  col += rTint;
  col = clamp(col, 0.0, 1.0);

  gl_FragColor = vec4(col, 1.0);
}
`;

// ------------------ COMPILATION HELPERS ------------------
function compileShader(gl, type, src) {
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);

  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
    console.error(gl.getShaderInfoLog(s));
    return null;
  }
  return s;
}

function createProgram(gl, vsSrc, fsSrc) {
  const p = gl.createProgram();
  const vs = compileShader(gl, gl.VERTEX_SHADER, vsSrc);
  const fs = compileShader(gl, gl.FRAGMENT_SHADER, fsSrc);

  gl.attachShader(p, vs);
  gl.attachShader(p, fs);
  gl.linkProgram(p);

  if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
    console.error(gl.getProgramInfoLog(p));
    return null;
  }
  return p;
}

// ------------------ PROGRAM + LOCATIONS ------------------
const program = createProgram(gl, vsSource, fsSource);
gl.useProgram(program);

const positionLoc     = gl.getAttribLocation(program, "aPosition");
const uResLoc         = gl.getUniformLocation(program, "uResolution");
const uTimeLoc        = gl.getUniformLocation(program, "uTime");
const uDampLoc        = gl.getUniformLocation(program, "uDamping");
const uCoupleLoc      = gl.getUniformLocation(program, "uCoupling");
const uNoiseLoc       = gl.getUniformLocation(program, "uNoise");
const uRhyLoc         = gl.getUniformLocation(program, "uRhythm");
const uGradLoc        = gl.getUniformLocation(program, "uGradient");
const uAttrLoc        = gl.getUniformLocation(program, "uAttractor");
const uCohLoc         = gl.getUniformLocation(program, "uCoherence");
const uAttrPosLoc     = gl.getUniformLocation(program, "uAttractorPos");
const uNoiseExtraLoc  = gl.getUniformLocation(program, "uNoiseExtra");

// ------------------ FULLSCREEN QUAD ------------------
const quad = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, quad);
gl.bufferData(
  gl.ARRAY_BUFFER,
  new Float32Array([
    -1, -1,   1, -1,   -1, 1,
    -1,  1,   1, -1,    1, 1
  ]),
  gl.STATIC_DRAW
);

gl.enableVertexAttribArray(positionLoc);
gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

// ------------------ PRESETS ------------------
const PRESETS = {
  A: {
    name: "A – still basin / settled",
    containment: "balanced",
    params: { damping:0.85, coupling:0.35, noise:0.15, rhythm:0.45, gradient:0.22, attractor:0.28 },
    description:
      "A gently settled field with low noise... groundedness without urgency."
  },

  B: {
    name: "B – diffuse scatter / reactive",
    containment: "porous",
    params: { damping:0.32, coupling:0.82, noise:0.78, rhythm:0.38, gradient:0.45, attractor:0.35 },
    description:
      "High reactivity, over-coupled, turbulent, low coherence."
  },

  C: {
    name: "C – flatline drift / low activation",
    containment: "balanced",
    params: { damping:0.78, coupling:0.28, noise:0.22, rhythm:0.30, gradient:0.16, attractor:0.10 },
    description:
      "Low activation, minimal drive, drifting."
  },

  D: {
    name: "D – coherent pull / focused",
    containment: "tight",
    params: { damping:0.52, coupling:0.48, noise:0.32, rhythm:0.65, gradient:0.82, attractor:0.88 },
    description:
      "Strong pull, structured focus, high coherence."
  },

  E: {
    name: "E – freefall / drive without destination",
    containment: "porous",
    params: { damping:0.40, coupling:0.20, noise:0.30, rhythm:0.55, gradient:1.00, attractor:0.00 },
    description:
      "Pure gradient. Urgency without clarity."
  },

  F: {
    name: "F – chaotic compression / overloaded",
    containment: "tight",
    params: { damping:0.25, coupling:0.65, noise:0.90, rhythm:0.25, gradient:0.75, attractor:0.95 },
    description:
      "Compression + noise → unstable overload."
  }
};

// ------------------ UI REFERENCES ------------------
const presetButtons    = [...document.querySelectorAll(".preset-btn")];
const presetDescEl     = document.getElementById("presetDescription");
const coherenceDisplay = document.getElementById("coherenceDisplay");
const containmentSelect = document.getElementById("containmentMode");

// sliders map
const sliders = {
  damping:   document.getElementById("damping"),
  coupling:  document.getElementById("coupling"),
  noise:     document.getElementById("noise"),
  rhythm:    document.getElementById("rhythm"),
  gradient:  document.getElementById("gradient"),
  attractor: document.getElementById("attractor")
};

// EVF Core (from external evf-core.js)
const evf    = EVFCore.state;
const tuning = EVFCore.tuning;

// ------------------ CONTAINMENT ------------------
let cMode = "balanced";

const CONTAINMENT_GAIN = {
  porous:   1.4,
  balanced: 1.0,
  tight:    0.6
};

containmentSelect.addEventListener("change", e => {
  cMode = e.target.value;
});

// ------------------ EMERGENT COHERENCE ------------------
function deriveCoherence(evf, cMode) {
  const directional = evf.gradient * evf.attractor;
  const stable      = evf.damping * evf.rhythm;
  const socialGlue  = evf.coupling * 0.5;

  const noisePenalty = evf.noise * 0.8;

  let containmentBoost =
    cMode === "porous"   ? 0.8 :
    cMode === "tight"    ? 1.15 :
                           1.0;

  let raw =
    (0.9 * directional +
     0.7 * stable +
     0.4 * socialGlue) * containmentBoost
    - noisePenalty;

  raw = Math.max(0, Math.min(1, raw));

  const SMOOTH = 0.10;
  return evf.coherence + (raw - evf.coherence) * SMOOTH;
}

// ------------------ APPLY PRESET ------------------
function applyPreset(key) {
  const preset = PRESETS[key];
  if (!preset) return;

  const p = preset.params;

  // UI sliders
  sliders.damping.value   = p.damping;
  sliders.coupling.value  = p.coupling;
  sliders.noise.value     = p.noise;
  sliders.rhythm.value    = p.rhythm;
  sliders.gradient.value  = p.gradient;
  sliders.attractor.value = p.attractor;

  // EVF values
  evf.damping   = p.damping;
  evf.coupling  = p.coupling;
  evf.noise     = p.noise;
  evf.rhythm    = p.rhythm;
  evf.gradient  = p.gradient;
  evf.attractor = p.attractor;

  // containment
  cMode = preset.containment;
  containmentSelect.value = cMode;

  // UI active state
  presetButtons.forEach(btn =>
    btn.classList.toggle("active", btn.dataset.preset === key)
  );

  presetDescEl.textContent = preset.description;
}

// hook events
presetButtons.forEach(btn =>
  btn.addEventListener("click", () => applyPreset(btn.dataset.preset))
);

   // ------------------ PARTICLE CANVAS ------------------
const pCanvas = document.getElementById("particles");
const pCtx = pCanvas.getContext("2d");
let particles = [];

function resizeParticles() {
  const rect = pCanvas.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;

  pCanvas.width  = rect.width * dpr;
  pCanvas.height = rect.height * dpr;
  pCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
}

// ------------------ INIT PARTICLES ------------------
function initParticles() {
  const rect = pCanvas.getBoundingClientRect();
  const w = rect.width;
  const h = rect.height;

  particles = [];

  const cfg = tuning.particles;
  const count = Math.floor(w * cfg.densityPerPixel);

  for (let i = 0; i < count; i++) {
    const size = cfg.sizeMin + Math.random() * (cfg.sizeMax - cfg.sizeMin);

    particles.push({
      x: Math.random() * w,
      y: Math.random() * h,
      vx: 0,
      vy: 0,
      size,
      phase: Math.random() * Math.PI * 2,
      life: Math.random() * 5,
      maxLife: 5 + Math.random() * 5
    });
  }
}

// ------------------ UPDATE ------------------
function updateParticles() {
  const rect = pCanvas.getBoundingClientRect();
  const w = rect.width;
  const h = rect.height;

  const gRaw = evf.gradient;
  const gVal = 0.03 + (1 - 0.03) * gRaw;

  const aVal = evf.attractor;
  const cVal = evf.coupling;

  const drive   = Math.max(gVal, aVal);
  const aimless = 1 - drive;

  const NOISE   = 0.02 + 0.06 * evf.noise;
  const DRIFT   = 0.02 + 0.06 * aimless;
  const ATTR    = 0.05 * aVal;

  const ax = w * 0.72;
  const ay = h * 0.65;

  const innerR = Math.min(w, h) * 0.06;

  const DAMP = (0.97 - evf.damping * 0.37);

  // cluster points
  const t = performance.now() * 0.00005;
  const clusterCount = 1 + Math.floor(cVal * 4);
  const clusters = [];
  const baseR = 0.12 + 0.10 * cVal;

  for (let i = 0; i < clusterCount; i++) {
    const angle = (Math.PI * 2 * i) / clusterCount;
    let cx = w * (0.5 + baseR * Math.cos(angle + t * 0.6));
    let cy = h * (0.5 + baseR * Math.sin(angle - t * 0.5));

    const bias = 0.35 * aVal;
    cx = cx * (1 - bias) + ax * bias;
    cy = cy * (1 - bias) + ay * bias;

    clusters.push({ x: cx, y: cy });
  }

  // gradient direction (fixed)
  const gx0 = w * 0.5;
  const gy0 = 0;

  let gdx = ax - gx0;
  let gdy = ay - gy0;
  const glen = Math.sqrt(gdx * gdx + gdy * gdy) + 1e-5;

  gdx /= glen;
  gdy /= glen;

  // MAIN LOOP
  for (let p of particles) {
    // aimless drift
    p.vx += (Math.random() - 0.5) * DRIFT;
    p.vy += (Math.random() - 0.5) * DRIFT;

    // pure gradient mode
    if (gRaw > 0.9 && aVal < 0.1) {
      const PUSH = 0.009 * gRaw;
      p.vx += gdx * PUSH;
      p.vy += gdy * PUSH;

      p.vx *= 0.5;
      p.vx *= DAMP;
      p.vy *= DAMP;

      p.x += p.vx;
      p.y += p.vy;

      if (p.x < 0) p.x += w;
      if (p.x > w) p.x -= w;
      if (p.y < 0) p.y += h;
      if (p.y > h) p.y -= h;

      p.life += 0.02;
      if (p.life > p.maxLife) {
        p.x = Math.random() * w;
        p.y = Math.random() * h;
        p.vx = p.vy = p.life = 0;
      }
      continue;
    }

    // low-drive
    if (drive < 0.12) {
      p.vx *= 0.97;
      p.vy *= 0.97;
      p.x += p.vx;
      p.y += p.vy;
      if (p.x < 0) p.x += w;
      if (p.x > w) p.x -= w;
      if (p.y < 0) p.y += h;
      if (p.y > h) p.y -= h;

      p.life += 0.02;
      continue;
    }

    // full-mode
    const dxA = ax - p.x;
    const dyA = ay - p.y;
    const distA = Math.sqrt(dxA*dxA + dyA*dyA) + 1e-3;

    const vanish = innerR * 0.6;
    if (distA < vanish && aVal > 0.15) {
      p.x = Math.random() * w;
      p.y = Math.random() * h;
      p.vx = p.vy = p.life = 0;
      continue;
    }

    if (distA < innerR) {
      const tInner = 1 - distA / innerR;
      const repel = 0.04 * (0.4 + aVal) * tInner * tInner;
      p.vx -= (dxA / distA) * repel;
      p.vy -= (dyA / distA) * repel;
    }

    // attractor pull
    p.vx += (dxA / distA) * ATTR * (0.3 + 0.5 * drive);
    p.vy += (dyA / distA) * ATTR * (0.3 + 0.5 * drive);

    // cluster pull
    if (clusters.length > 0 && cVal > 0.05) {
      let closest = clusters[0];
      let minD2 = (p.x-closest.x)**2 + (p.y-closest.y)**2;

      for (let c of clusters) {
        const d2 = (p.x-c.x)**2 + (p.y-c.y)**2;
        if (d2 < minD2) {
          minD2 = d2;
          closest = c;
        }
      }

      const dxC = closest.x - p.x;
      const dyC = closest.y - p.y;
      const distC = Math.sqrt(dxC*dxC + dyC*dyC) + 1e-3;

      const pull = 0.05 + 0.18 * cVal;
      p.vx += (dxC / distC) * pull;
      p.vy += (dyC / distC) * pull;
    }

    // noise
    p.vx += (Math.random() - 0.5) * NOISE;
    p.vy += (Math.random() - 0.5) * NOISE;

    // damping
    p.vx *= DAMP;
    p.vy *= DAMP;

    p.x += p.vx;
    p.y += p.vy;

    const bias = 0.008 * (aVal * aVal);
    if (bias > 0) {
      p.x += (ax - p.x) * bias;
      p.y += (ay - p.y) * bias;
    }

    if (p.x < 0) p.x += w;
    if (p.x > w) p.x -= w;
    if (p.y < 0) p.y += h;
    if (p.y > h) p.y -= h;

    p.life += 0.02;
  }
}

// ------------------ DRAW ------------------
function drawParticles() {
  const rect = pCanvas.getBoundingClientRect();
  const w = rect.width;
  const h = rect.height;

  const ax = w * 0.72;
  const ay = h * 0.65;
  const innerR = Math.min(w, h) * 0.09;

  pCtx.clearRect(0, 0, w, h);

  for (let p of particles) {
    const fade = 1 - p.life / p.maxLife;

    const rhythm = 0.4 + 0.6 * evf.rhythm;
    const osc = 0.5 + 0.5 * Math.sin(p.life * 1.5 * rhythm + p.phase);
    const radius = p.size * (0.6 + 0.7 * osc);

    const dist = Math.sqrt((p.x-ax)**2 + (p.y-ay)**2);
    const distNorm = Math.min(1, dist / (innerR * 3));

    const blueBias = (1 - distNorm) * 20;
    const centerFade = Math.min(1, dist / innerR);

    let alpha = (0.10 + 0.25 * fade) * centerFade;

    // porous containment + extra noise → boost visibility
    if (cMode === "porous" && tuning.noiseExtra > 0 && evf.noise > 0.5) {
      alpha *= 1.8;
      alpha = Math.min(alpha, 0.7);
    }

    const g = Math.floor(180 + Math.random() * 60);
    const r = Math.max(0, g - blueBias);

    pCtx.fillStyle = `rgba(${r},${r},${g},${alpha})`;

    pCtx.beginPath();
    pCtx.arc(p.x, p.y, radius, 0, Math.PI * 2);
    pCtx.fill();
  }
}

// ------------------ DEV PANEL ------------------
const devPanel = document.getElementById("devPanel");
const pDensityInput = document.getElementById("pDensity");
const pSizeMinInput = document.getElementById("pSizeMin");
const pSizeMaxInput = document.getElementById("pSizeMax");

const pDensityVal = document.getElementById("pDensityVal");
const pSizeMinVal = document.getElementById("pSizeMinVal");
const pSizeMaxVal = document.getElementById("pSizeMaxVal");

const devCopyBtn = document.getElementById("devCopyBtn");
const devNoiseExtra = document.getElementById("dev-noise-extra");

tuning.noiseExtra = 0;

devNoiseExtra.addEventListener("input", e => {
  tuning.noiseExtra = e.target.checked ? 1 : 0;
});

function syncPanel() {
  const cfg = tuning.particles;
  pDensityInput.value = cfg.densityPerPixel;
  pSizeMinInput.value = cfg.sizeMin;
  pSizeMaxInput.value = cfg.sizeMax;

  pDensityVal.textContent = cfg.densityPerPixel.toFixed(1);
  pSizeMinVal.textContent = cfg.sizeMin.toFixed(2);
  pSizeMaxVal.textContent = cfg.sizeMax.toFixed(2);
}

function applyPanel() {
  const cfg = tuning.particles;

  cfg.densityPerPixel = parseFloat(pDensityInput.value) || cfg.densityPerPixel;
  cfg.sizeMin         = parseFloat(pSizeMinInput.value) || cfg.sizeMin;
  cfg.sizeMax         = parseFloat(pSizeMaxInput.value) || cfg.sizeMax;

  if (cfg.sizeMax < cfg.sizeMin) {
    cfg.sizeMax = cfg.sizeMin + 0.05;
    pSizeMaxInput.value = cfg.sizeMax;
  }

  syncPanel();
  initParticles();
}

[pDensityInput, pSizeMinInput, pSizeMaxInput].forEach(inp =>
  inp.addEventListener("input", applyPanel)
);

devCopyBtn.addEventListener("click", () => {
  const cfg = tuning.particles;
  const json = JSON.stringify(cfg, null, 2);
  navigator.clipboard?.writeText(json).catch(() => {});
});

window.addEventListener("keydown", e => {
  if (e.key.toLowerCase() === "p") {
    devPanel.classList.toggle("hidden");
  }
});

// initialize panel
syncPanel();

// ------------------ LERP HELPER ------------------
function lerp(a, b, t) {
  return a + (b - a) * t;
}

// ------------------ MAIN RENDER LOOP ------------------
const t0 = performance.now();

function render() {
  resizeGL();
  gl.useProgram(program);

  const t = (performance.now() - t0) / 1000;

  const gamma = CONTAINMENT_GAIN[cMode];

  // target values from sliders
  const targetDamp      = parseFloat(sliders.damping.value);
  const targetCoupling  = parseFloat(sliders.coupling.value)  * gamma;
  const targetNoise     = parseFloat(sliders.noise.value)     * gamma;
  const targetRhythm    = parseFloat(sliders.rhythm.value);
  const targetGradient  = parseFloat(sliders.gradient.value)  * gamma;
  const targetAttractor = parseFloat(sliders.attractor.value) * gamma;

  const speed = 0.08;

  evf.damping   = lerp(evf.damping,   targetDamp,      speed);
  evf.coupling  = lerp(evf.coupling,  targetCoupling,  speed);
  evf.noise     = lerp(evf.noise,     targetNoise,     speed);
  evf.rhythm    = lerp(evf.rhythm,    targetRhythm,    speed);
  evf.gradient  = lerp(evf.gradient,  targetGradient,  speed);
  evf.attractor = lerp(evf.attractor, targetAttractor, speed);

  // coherence = emergent
  evf.coherence = deriveCoherence(evf, cMode);
  coherenceDisplay.textContent = evf.coherence.toFixed(2);

  // uniforms
  gl.uniform2f(uResLoc, gl.drawingBufferWidth, gl.drawingBufferHeight);
  gl.uniform1f(uTimeLoc, t);

  gl.uniform1f(uDampLoc,   evf.damping);
  gl.uniform1f(uCoupleLoc, evf.coupling);
  gl.uniform1f(uNoiseLoc,  evf.noise);
  gl.uniform1f(uRhyLoc,    evf.rhythm);
  gl.uniform1f(uGradLoc,   evf.gradient);
  gl.uniform1f(uAttrLoc,   evf.attractor);
  gl.uniform1f(uCohLoc,    evf.coherence);

  // micro-noise containment gating
  const baseExtra = tuning.noiseExtra;
  const noiseExtraEff =
    cMode === "tight"    ? 0.0 :
    cMode === "balanced" ? baseExtra * 0.5 :
                           baseExtra;

  gl.uniform1f(uNoiseExtraLoc, noiseExtraEff);

  // attractor position (normalized)
  gl.uniform2f(uAttrPosLoc, 0.72, 0.45);

  // draw
  gl.drawArrays(gl.TRIANGLES, 0, 6);

  updateParticles();
  drawParticles();

  requestAnimationFrame(render);
}

// ------------------ INIT ------------------
resizeGL();
resizeParticles();
initParticles();
render();

   
    
  </script>
</body>
</html>
